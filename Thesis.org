#+TITLE: Composition of UI elements in reacl-c using monads
#+AUTHOR: Marlon Schlosshauer, Applied Computer Science, Hochschule Offenburg
#+LANGUAGE: english
#+OPTIONS: \n:t
#+OPTIONS: toc:nil
#+OPTIONS: broken-links:auto
#+LATEX_HEADER: \hypersetup{colorlinks=true, linkcolor=black}

#+LATEX: \newpage
#+TOC: headlines
#+LATEX: \newpage

* Abstract
Composition of UI elements is a necessary and well supported tool in modern frontend development. However, in this thesis we discuss that composing UI elements could be split into parallel- and sequential-composition. We explain the difference between them, go into detail about why sequential composition is important, examine the current support for it (or lack thereof) and explore a developer friendly interface.
Furthermore, we show what real-c is and compare it to React, before implementing the previously proposed interface for it. At the end we give examples for using our implementation for sequential composition and discuss possible improvements to the implementation.
* Motivation
Components are an important tool in modern frontend development. In traditional frameworks we can define something as a component, to reuse it multiple times in our applications, encapsulate some style with some functionability or collect multiple elements into a single component. To be more precise, we can compose things in parallel, as we can group elements into something that is to work together with each other. An example of a parallel composition would be two input fields and a button, which together define a sign-in component.

#+CAPTION: Example of parallel composition of a sign-in component. The first composition is a button and two inputs. The result of the first composition is further composed by adding a headline. That result is then further composed by adding a logo.
#+ATTR_LATEX: :width 350px
[[./images/parallel-composition-highlighted.png]]

However, modern frontend applications have gone beyond just serving information with HTML. They act as a digitalization of a workflow, where the order of components, as in which component is shown after another, is crucial. This is also a kind of composition. Instead of composing things in parallel, we're composing sequentially here. This is to say, we say which steps we have and together they form a sequence.
The resulting sequentiality is different from how we know it from imperative programming, as we don't mutate state with each step, rather the result of each step is fed into the next step. This allows us to adress the essential sequentiality of the domain while not creating accidental sequentiality, because sequentiality isn't our only tool. *TODO*
An example of a sequential composition would be to first show a sign-in component, then after a successful login show the actual component the user wanted to access.
An example of a sequential composition would be to first ask the user for their e-mail address, then after having the user enter a valid e-mail, showing the user an input field for a code that was sent to them, using their e-mail. Notice that the second step depends on information that was gathered by the previous step.

#+CAPTION: Example of sequential composition of a sign-up component. The first composition combines two steps and is further composed by adding a third step.
#+ATTR_LATEX: :width 350px
[[./images/sequential-composition-highlighted.png]]

Because of this dependency composing sequentially isn't just an optimization, it's a fundamental building block of how an application is supposed to operate. Just how we need the ability to show both an input field and a button at the same time (to confirm the input), we also need the ability to model what happens after (and possibly before) that button has been pressed.

But despite the need, the actual support for sequential composibility by modern frameworks is either non existent or very poor.
While some of the desired result can be achieved by making clever use of parallel composibility or using traditional links and routing, neither is truly sequentially composible and both suffer from multiple issues, some of which are:
- They don't yield things which we can compose further (into more complicated workflows)
- Reusing these components leads to a lot more abstraction
- It produces code that becomes difficult to understand at a glance (or at all)
- Most importantly the logic for advancing the steps and the book-keeping lives now inside the component with the parallel composing logic
There are more issues like the inability to easily test just the order of the components and the huge time cost required to refactor constructs of this nature.

Our applications already are a collection of parallel compositions. If we add the ability to compose sequentially, we can use another axis to control our programs and build complicated hierchies, where an application consistst of one sequentially composed component, that inside of it has either more sequentially or parallel composed components.
Not only would our code be more expressive and more concise, bugs could also be reduced because the systems we build can be represented more truthfully by the provided api of the framework. But most importantly we could build workflows out of smaller flows or other workflows entirely and share these across our applications, just how do with ui elements.
Given the lack of support and possible application it is of high interest to find a way to compose sequentially, easier.
* What is React
React is a popular UI framework developed by Meta (formerly Facebook) and written in JavaScript. Like other modern JavaScript frameworks, it is a Single-Page-Application (SPA), which means the entire application is available and loaded from a single page. Instead of having each page defined in HTML, developers are able to define their pages in JavaScript, using Reacts JavaScript Syntax Extension (JSX). React takes those JSX definitions and builds HTML accordingly, before adding it to the browsers DOM.
#+CAPTION: Example of JSX to define a profile
#+begin_src javascript
  const profile = ({name, age, image}) => {
      return (
	  <div className="profile-container">
	    <div className="profile-info-container">
	      <p>{name}</p>
	      <p>Age: {age}</p>
	    </div>
	    <img alt={`Avatar of ${name}`} src={image}/>
	  </div>
      )
  }
#+end_src

An advantage of a SPA design is that commonly used components, like a header and footer, can be shared over multiple pages without having to be retransmitted, as the JavaScript code is still in memory. In such a system navigation does not change the current page, but rather tells React to build the desired next page from the JSX definition. Besides requiring less bandwith on succesive visits, this also leads to better response times on page visits after the initial load, as those pages are also already in memory.

Another important feature of React is that the developer must explicitly declare the state of a component. This is used to improve performance, as only components which
which are effected by a state change are freshly render. Old components remain untouched in memory.

React is also a popular basis for other frameworks like Preact, Reagent, reacl-c and others.
* What is reacl-c
Reacl-c is a UI framework for ClojureScript that is designed to make the composition of UI components easier. Like other ClojureScript frameworks (Reagent, Om, Rum), reacl-c wraps React to take advantage of Clojures immutable datastructures. Like React, reacl-c allows the defining of components, called "items" in reacl-c. These items can have child items, thus forming a tree, just like in React.

To make composing of items easier, reacl-c takes a different approach to state than React. There are two types of state. Local state, which is defined inside of the component and outter state, which is implicitely passed down from the parent to the child. The later puts the emphasis on the parent.

A key difference to React, is that items can emit actions if an event occurs. These actions propogate upward the item tree. Every item can register an action handler which captures the action and reacts to it. This enables the developer to define a (child) item completely independently from their potential future parents, leading to more reusable and more composible components.
Instead of having the parent pass down a function to, e.g manipulate state, the component can emit an action upwards and trigger the same functionability in the parent. Another benefit is that the parent component can adapt the output of the emitted action further.

#+CAPTION: Showcasing the inversion of control by comparing emiting of actions to passing down callbacks. Each circle is a component. To communicate the callbacks need to be passed down. With actions, the children can speak up on their own.
[[./images/emit-vs-callback.png]]

As an example: A button toggles an "option" from ~true~ to ~false~ and back. The state for this "option" is put into the parent, as the child will be reused across the application. In React, the button needs to receive a function which to callback, after the button had been pressed. In reacl-c the button does not need to receive anything from the outside world (necessarily, styling and text might be applied), as the button emits an action when pressed, which the parent can capture and act upon.
#+CAPTION: We create an item called ~abstract-button~ which contains a button. If pressed, it's going to fire an ~:action~ with the value ~:pressed~ to it's parent.
#+begin_src clojure
  (defn-item abstract-button [text]
    (dom/button {:onClick (fn [] (core/return :action :pressed))} text))
#+end_src
With this style of communication, only the parent needs to know the child. The developer does not need to tell the child where to send the action. Reacl-c takes care of that work for us.

To make components even more composible the parent can not just control the result, it can also control which state is given to it's children in the first place. The parent can therefor handle the child items like they're pure functions, that together with the parent compose to a new item.

In React often another package like Redux is used to fix the problem of having to passdown functions. Instead of saving all state in each component, state can be managed at a central point which components can send messages to, causing the central state to change. This can cause issues with the composibility of components. The problem with this approach is that components cannot be placed multiple times into the app, without making sure they don't all work on the same central state. Reacl-c solves this issue by allowing any component to send and receive messages. Not only does this allow for local reasoning, but it also enables to wrap a component with an action handler and placing it infinitely in the app without worry, as the component won't effect anything outside of that handler.
** How an Item is made
Reacl-c is made up of so called items and functions which operate on these items. Much like in React they are instructions that represent HTML elements that can be nested and can hold state.
To make an item reacl-c provides a namespace called ~dom~ that contains all the necessary DOM HTML components already defined as items. All that is needed to create a headline is ~(dom/h2 "Headline")~. To make more complicated items, combinators like ~(dom/div)~ or ~(core/fragments)~ can be used. These can contain multiple items.
#+CAPTION: Showcasing composition of multiple items into one by using a div
#+begin_src clojure
  (dom/div
   (dom/h2 "Hello")
   (dom/p {:class "subtitle"} "This is some text")
   (dom/button "Subscribe"))
#+end_src
There are other functions which, much like div, don't add something visually but change the behaviour of the item. Functions like ~core/focus~, ~core/dynamic~ and ~core/handle-actions~, to just name a few.

Items can also receive a map as their first argument. With this map things like CSS classes, inline-style can be provided. If the item is an interactive one like Buttons and inputs (to name a few), the keywords ~onChange~ and ~onChange~ can be used to register a callback.
** Emitting and handling actions
Actions are an important tool for children to communicate with their parents. Like the implicit (or explicit) passing of state from the parent, this is a crucial feature to make items composible.
To emit an action the child needs to call ~core/return~ with the ~:action~ keyword and the desired payload. The action will travel upwards until it's caugh by a ~core/handle-action~. Handle action takes two arguments, first an item to wrap (and receive actions from) and second a function that defines what do to when it received an action.
#+CAPTION: The action emitted by the buzzer item is caught in the parent item
#+begin_src clojure
  (def buzzer
    (dom/dom
     (dom/h3 "Press buzzer to notify parent")
     (dom/button {:onClick (fn [] (c/return :action true))} "Buzzer")))

  (def parent
    (core/local-state
     {:pressed? false}
     (c/handle-action
      (core/dynamic
       (fn [[outter inner]]
	 (dom/div
	  (dom/p (str "The button has" (if (:pressed? inner) "been pressed" "not been pressed")))
	  buzzer)))
      (fn [ac msg]
	(c/return :state {:pressed? msg})))))
#+end_src
It is important that the function which given to ~core/handle-action~ calls ~core/return~ at the end to either notify a parent of itself or change state, as an action is just a side-effect.
** How state is managed
Like with React, handling state is very important in reacl-c. The framework gives the developer many ways to tackle the problem. Thankfully, much like with React, the developer can easily make out if a component is using or changing state.

State in reacl-c can be shared in different, more complex, ways.
Firstly, while a component might have state, it is not accessable to the developer until they use the ~core/dynamic~ function. This has the benefit of instantly marking a component as one that needs and works with state.
Secondly, state is split into two categories:
- Inner state, which is defined inside of the component by using either ~with-state-as~, ~local-state~ or ~isolate-state~.
- Outter state, or state that is passed down from the parent component.
The inheritance of state from the parent happens implicitely, but can be controlled by the parent through lenses (with the ~core/focus~ function). Like mentioned earlier, this part of the reason why reacl-c items are so composible.

While ~with-state-as~ allows us to add additional state to our component, the ~dynamic~ function gives us access to all the state that this component has to offer. These two functions are often used together, to create a component that needs to both have local state and react to it.
#+CAPTION: Using ~local-state~ to create an inner state of an empty string, which is being changed by the ~onChange~ callback of the input.
#+begin_src clojure
  (c/defn-item name-input [placeholder]
    (c/local-state
     ""
     (c/dynamic
      (dom/input
       {:placeholder placeholder
	:value inner
	:onChange (fn [[outter inner] e] (c/return :state [outter (.. e -target -value)]))}))))
#+end_src
To change state the ~core/return~ function is used again. This time with the ~:state~ keyword, instead of ~:action~. The given payload will be the new state of the component.
* What is a monad
There are different kinds of Monads that serve different purposes. In general, monads are often described as the programmable semicolon, because they allow us to describe what happens once an operation, that uses a monad, is done. One use case for some monads is to allow us to chain operations on often abstracted away types to transform data or control flows. In order to allow for sequential composition we need to make use of both, with a focus on controlling when what is executed and shown.
** The Maybe Monad
A popular monads is the ~Maybe~ type in Haskell. The language doesn't feature a ~null~ value, instead we can use ~Maybe~ to express when a function might be return ~Nothing~ or ~Just~ of something. What makes this type a monad is the fact that we can chain it together. This allows us to combine multiple operations that might fail and stop execution in case any of them do.
#+CAPTION: Instead of having to manually check if each operation succeded, thanks to the ~Maybe~ type and >>= operator, the chain will stop if one of the calls return a ~Nothing~
#+begin_src haskell
  getUserById "df743aec" >>= getTeamByUser >>= getTeamManagerByTeam >>= getSalaryById
#+end_src

Monads are everywhere around us and most developers will have used them, even if they didn't know what a monad is. They help us write cleaner code that is easier to share, because the actual logic is hidden away, yet allow us to continue to easily use them, because they're composable.
Common cases for monads are IO operations, handling of errors, UI work and to establish a context of values.
** Whats required to be a monad
To be a monad a type needs to implement two functions and comply with three rules. The required functions are ~>>=~ (also called bind) and ~return~.
A bind takes an instance of a monad ~M~ and takes a function that gets a normal value and returns another instance of that type ~M~. The bind function return the result of the second argument, the passed function. We give it a monad and a function and get another monad out. This is what enables us to chain these operations together.
The second function, the ~return~, takes a value and makes a monad out of it. This usually means wrapping the value in a monad type. As an example ~Just 1~ works like a return, in that we give it a ~1~ and it gives us a ~Maybe~ value (with the value of 1 inside of it). Return is sometimes also referred to as ~pure~.

It's often helpful to see these functions in the Haskell notation, to understand them. See Listing for more.
#+CAPTION: Haskell notation of the functions bind and return
#+begin_src haskell
  M a >>= (a -> M b) = M b
  return a = M a
#+end_src

Our implementation of these functions need to fullfill the following three rules to be considered a monad:
- Left identity: ~return a >>= h = h a~
- Right identity: ~m >>= return = m~
- Associativity: ~(m >>= g) >>= h = m >>= (\x -> g x >>= h)~

Left and right identity are tests to make sure the types work out correctly. ~return~ can both be called with a value to create a monad, when provided on the left side of the bind, or be given as a continuation function, if provided on the right side. The rule of associativity tests that the order of operation is not important. Both ~(A >>= B) >>= C~ and ~A >>= (B >>= C)~ should yield the same result.
* Current State
Composition is supported in both reacl-c and other frontend frameworks like Angular or React etc. However, this is limited to creating a new component that just displays all composed components at the same time. In other words it's only possible to compose in parallel. To create a component which initially display some component and later changes to display another component, after a certain event has been reached (composing sequentially), the logic doing the change from one to the other component, needs to be implemented by hand. In the following we're going to examine some possible ways to implement a sequence of steps.
** If statement
While not offering composibility, a simple ~if~ statement is highly effective for binary choices when it comes to displaying components. An example would be to guard dashboards and such behind an ~if~ statement, to check if the user is logged in. If they aren't, the login page (instead of the dashboard) is shown.
#+begin_src javascript
  const app = (isLoggedIn) => {
      return (isLoggedIn)
	  ? <login/>
	  : <dashboard/>
  }
#+end_src
** Switch statement
A common way to implement this, is to use a switch statement in combination with a variable to keep track of state. Once a certain event (like a click on a button) has occured, the component changes the state to allow for the next component to be rendered.
#+begin_src javascript
  const login = () => {
      const [step, setStep] = useState(0);
      const [value, setValue] = useState();

      const cb = x => {setStep(step+1); setValue(x)};

      return switch(step) {
	  case 0:
	  return (<personalInfo value={value} cb={cb}/>) ;
	  case 1:
	  return (<verificationCode value={value} cb={cb}/>) ;
	  case 2:
	  return (<showAccountInfo value={value}/>) ;
      }
  }
#+end_src
A simple implementation of a component which shows multiple components succesively can be seen in Listing 1. ~personalInfo~, ~verificationCode~, ~showAccountInfo~ are components that will be shown one after another. The ~step~ variable stores which component should currently be shown. The ~value~ variable stores the result of the last step. In order to progress, a callback named ~cb~ needs to be passed to all components, as the point at which the child components are finished can't be deteremed from outside (in React). The steps are arranged in sequential order, but it is also possible to move non-linearly or even revisit components mutliple times. This does mean the callback function needs to map from where which component is being routed. This will be examined in more detail in Listing 2.
Another property to keep in mind is that the components need to be able to at least take a callback function for when they're done. This means components might need to be changed to fit our new logic.
#+begin_src clojure
  (defn login []
    (handle-action
     (dynamic
      (fn [[step val]]
	(case
	    :personal (personal-info val)
	    :verification (verification-code val)
	    :show (show-account-info val))))
     (fn [[step _] ac]
       (return
	:state
	[(case step
	   :personal :verification
	   :verification (if (nil? ac) :verification :show)
	   :show :show) ac]))))
#+end_src
Listing #2 shows the example from Listing 1, but it's written in reacl-c and instead of using an increasing number to keep track of which step the component is on, a keyword is used which could be used to show components in a non-linear order, loop back to the inital component after visiting the final component or to show a component multiple times (with different values each time). But this means a second switch statement is needed, to map the transitions from one component to another.

This causes multiple issues. The most immidiate is that it's more difficult to add more components, as two places need to be maintained to do so. It is also very easy to lose track of which component will be shown next, if a complex order is choosen, as no support is being provided by either the language nor the framework. There is also no check if the pattern is non-exhaustive.
Importantly, this also cannot be further composed! With the implementation in Listing 1 or Listing 2, it is not possible to wrap them with a similiar structure, as the inner component has currently no way to signal to the outter component, that the next step is to be displayed. We solved this problem inside of the inner component by passing a callback down, to call us once the next step should be displayed.
We could preemptively add a callback to our ~login~ component, which would be called once the component is done, in case we'd ever need it in the future. This makes our component sequentially composible, however adds even more code to our component. It also requires that we keep track of our steps at yet another place, the point which determinds if the component is done (and the final callback should be called). See Listing 3 for more.
#+begin_src javascript
  const login = (onFinish) => {
      const stepCount = 3;
      const [step, setStep] = useState(0);
      const cb = x => {
	  setValue(x);
	  if (onFinish && step >= stepCount) {
	      onFinish(x)
	  } else {
	      setStep(step+1);
	  }
      };

      return switch(step) {
	  case 0:
	  return (<personalInfo value={value} cb={cb}/>) ;
	  case 1:
	  return (<verificationCode value={value} cb={cb}/>) ;
	  case 2:
	  return (<showAccountInfo value={value}/>) ;
      }
  }
#+end_src
While meeting all functional requirements, the implementation provides poor useability. First, we need to write a lot of boiler place, because we can't abstract away the switch statement, as we need direct knowledge about it for our core functionality. Secondly, we need to be aware and handle edge-cases like not being provided a callback, yet having child components continue to ask for a next step. Thirdly, nothing is stopping us from doing parallel work in our sequential composition. This means our sequential composition could be used to also sneak in parallel changes, that could lead to unexpected behaviour.
** Callbacks
We have already explored one possbile solution to sequential composition, using a switch statement. However we had to fall back to using callbacks to implement our logic. It is also possible to skip the switch statement and just use callbacks. This has the benefit of relieving us of a lot of code and making it easier at a glance to understand what is happening.

One idea for a component that is sequentially composible is shown in Listing #5, while usage is shown in Listing #6.
#+CAPTION: Definition of a composible component using callbacks. The ~cb~ callback function will be called once if the user clicks the button. The result of the callback is saved as state and will be shown, instead of the the now old component.
#+begin_src javascript
  const personalInformation = (cb) => { // callback received as parameter
      const [result, setResult] = useState();

      const [email, setEmail] = useState();
      const [password, setPassword] = useState();

      return (result) // display result if present
	  ? result
	  : (<div>
	     <input onChange={setEmail} value={email}/>
	     <input onChange={setPassword} value={password}/>
	     <button onClick={() => setResult(cb(email))}>Continue</button> //callback called and result saved
	     </div>)
  }
#+end_src

At the core it's not much different than the switch-case. We pass down a callback, which will be called once the next step is to be shown. The difference is that the book keeping for the next step isn't centralized at the top, but takes place at each and every step, inside of the component. The components themselves can be composed further by making sure the callback itself takes yet another callback, to continue the chain.

#+CAPTION: Compose our steps like in the switch-case example, by building up a chain of function and passing it to our initial step.
#+begin_src javascript
  const login = () => {
      const cb = (email) => <verificationCode email={email} cb={() => <showAccountInfo/>}/>; // compose our steps
      return <personalInformation cb={cb}>
  }
#+end_src
Thanks to the flexibility of callbacks, we can now fully compose sequentially. However, this implementation has a couple of shortcomings. Firstly, we need to keep track of a lot of callbacks. This leads to code that is unpleasent to read (e.g composing mutliple steps in Listing #6). Secondly, we still need to write a lot of code every time we want a sequentially composible component. There is potential to abstract some of it away, but that needs a lot more abstraction to be viable. Writing a lot of code isn't necessarly bad, but could introduce typos and bugs of that nature. It also means we have more code that we might want to test.
Most importantly, we mix our parallel and sequential composition. We want the logic to be seperated, because they do different things. Yet every parallel component now needs to do book keeping as well.
Lastly, besides the parameter, there is no way to distinguise from the outside if this is a sequential or parallel component. Placing a single step of a sequential composition into a parallel composition might not make sense and we'd like to make this not possible on an API level.
** Conclusion
Current methods either don't offer composibility or they require a lot of boilerplate to be composible. It is possible to write functions which abstract that boilerplate code away, but that takes time and effort. Support from modern frameworks could fill this gap and enable this kind of composition while also delivering smooth integration with other features of the framework.
* Desired Behaviour
The goal is to create both an easy to use yet powerful tool to compose sequentially. Unlike with parallel composition, there are little examples to go off of. Because of this it's easy to draw inspiration from other, already in use functions.
ClojureScript already provides something that allows us to define things in a neat way, with the ~let~ function. As seen in Listing 3, a ~let~ is composed of two parameters. The first parameter is a list of ~mapping:value~ pairs, where a mapping is nothing but a name to be used within the ~let~ and a value is the actual value of that name. The second parameter, the body, is a function which can use the mappings given in the first parameter, to execute some operation.
#+CAPTION: Using ~let~ to bind values to the names ~one~, ~two~, ~three~
#+begin_src clojure
  (let [one 1
	two (+ 1 one)
	three (inc (* two one))]
    (+ one two three))
#+end_src
Another benefit of adopting this style is that ClojureScript developers would already be familiar with it.

An important feature for our sequantial composition is the need for synchronosity. Only one value is to be shown to the user at a time and that is the current value in our list of ~mapping:value~ pairs. Execution of pairs further in the list is halted until they're reached. The same should hold true for HTTP requests which could be added to the list.
Future pairs should also be able to access the value returned by the earlier pairs, just like how you can access ~one~ while calculating the value of ~two~ in our ~let~ example earlier.
Individual values in the ~mapping:value~ pairs should also be able to be composible with other values, so one step in one flow, can be an entire different, nested, flow. For that we need a function to compose further.

Listings 5 shows our earlier example implemented with the desired functionality given by the framework. Note how little code is needed. This example still closely follows ~let~ in that it needs an uneven amount of arguments, in which the last is a function that will be executed (with access to all the previously declared names) at the end.
#+CAPTION: Earlier login example written in a ~let~ style
#+begin_src clojure
  (runner [personal (personal-info)
	   verification (verification-code personal)]
	  (show-account-info [personal verification]))
#+end_src
A possible alternative to this would be to omit the body function entirely and instead use the element previously placed in the body (~show-account-info~ in our example), as the last element in our ~mapping:value~ pairs list. While breaking with the ~let~ style, this has the benefit of creating a concise and consistent look and feel.
#+CAPTION: Login example in ~let~ style without a body function
#+begin_src clojure
  (runner [personal (personal-info)
	   verification (verification-code personal)
	   info (show-account-info [personal verification])])
#+end_src
The ~runner~ function executes our composition and should be able to be used just like a regular item when wanted. It should be able to be composed parallel with other items and actions should be able to be caught from it.
Inside of the ~runner~ we will have steps, those steps should be composible thanks to another function. For now we can steal terminology from monads and call this function ~bind~ or ~then~.
These two functions should be the primitives of our implementation.
* Why composition is important
Composibility is hugely important for software developer. Not only can we compose functions with other functions, but it is also what allows us to build modern UI elements so effortlessly. It even got its own OOP software pattern in the form of "Favor Composition over Inheritance" pattern.

The benefits are plentiful. Arguably the biggest advantage is that it allows us to construct bigger things out of multple smaller things. This in turn allows us to break a problem into multiple pieces. Being able to address one concern at a time, we can not only test each piece on their own but also share components easier. Another big benefit is that we can, if constructed correctly, add to our composition forever. Because code evolves over time, this is an appealing property to have.
Both of these attributes are important for frontend development, as we both want to be able to re-use our components and continue to add to them without worry.
* API Design
This being the first step of introducing sequential composition into reacl-c, it was important to provide strong primivates. Reacl-c already has excellent tools for parallel composition, so the sequential composition should mirror them, to be intiuitive for developers.
The implementation needs to also hide the heavily lifting done in the background and not cause any unexpected issues, that would cause it to become unuseable for any scenario. The sequential composition should not interfere with the parallel one and the borders between the two should be clearly visible. Most importantly, developers should be able to compose sequentially how ever they like without any limitations.
** Used types
While ClojureScript is a dynamically typed language, it is helpful to create types using Clojures ~records~, to make handling and transforming data easier.
The most fundermental type is an UI element, which reacl-c already supplies in the form of ~Item~. To signal that the next step should be executed, the ~Item~ needs to emit something, which can be recognized internally. For that purpose the ~Commit~ record exists. If an ~Item~ emits a ~Commit~, the internals will execute the next step.
A developer could just pass an ~Item~ for composition, however, it makes sense to have the developer acknowledge that they're working with more than just a simple ~Item~. After all, the ~Item~ should at some point emit a  ~Commit~ to change the currently shown step. So, to be able to use the item for seq. composition, the developer needs to wrap it in a ~Prog~. This signals that the developer understood that the ~Item~ will eventually emit a ~Commit~. Perhabs further work  could be here, to guarente that a developer is alerted if their code never emits a ~Commit~.
In short:
- Item: UI Element
- Commit: What an Item emits to signal next exection
- Prog: An Item that will Commit
Internally, there is also a ~Bind~ type, which is the result of a ~then~ call. This holds both a ~Prog~ and a continuation, that will be called once a ~Commit~ has been captured.
** Functions exposed by the API
To deliver on the promises of frictionless composibility without loss of performance, monads are used. Because of that, the API needs to provide the ~return~ and ~then~ (also called ~bind~) functions to be considered a monad. Further, to display a ~Prog~ or ~Bind~ easily, a ~show~ function has been added. The most important function is ~runner~, which executes a ~Prog~ or ~Bind~ inside of it, allowing it to walk through the provided steps.
The primivate functions are ~return~, ~then~ and ~runner~.
*** return
The ~return~ function takes an ~Item~ and turns it into a ~Prog~. This allows to go from a parallel composition (with an ~Item~) to a sequential composition (of a ~Prog~). Once an ~Item~ is a ~Prog~ the result can't be further parallely composed.
*** then
The ~then~ function is what allows us to compose multiple ~Progs~ together. For that it takes both a ~Prog~ and a ~continuation~ function (which should return another ~Prog~). The ~continuation~ will be called later, in the ~runner~ function. ~then~ creates a value of type ~Bind~ by passing the ~Prog~ and ~continuation~ parameters along. To allow for composition, the developer can also pass a ~Bind~ instead of a ~Prog~. The ~Bind~ in that case would be a previously created composition.
The goal of ~then~ is to allow for easy composition, just like ~div~ from the ~dom~ namespace of reacl-c. Further composing of a ~Prog~ into another ~Prog~ can be done again with the ~then~ function. It is important that the order of execution will be preserved, no matter the depth of composition.
*** runner
A ~Bind~ cannot be placed directly into a reacl-c ~Item~. To do so, either ~show~ or ~runner~ needs to be used, to translate the sequential composition into a parallel composition. While ~show~ just displays the ~Item~ inside, the ~runner~ function acts as a window into sequential execution, as it captures emitted ~commits~ and cycles through the given steps.
It takes a single ~Bind~ as an argument, which could contain further ~Binds~ inside of it. Once a ~commit~ is emmitted from the ~Bind~ that it displays, it calls the ~continuation~ of the ~Bind~ and displays the result of that ~continuation~. If the result is another ~Bind~, emitting another ~commit~ will trigger a call to the ~continuation~ of the new ~Bind~, which should produce yet another ~Bind~ etc.
*** show
~show~ extracts the ~Item~ from the passed variable, allowing it to be displayed. If it's a ~Prog~ it just takes the ~Item~ inside of the ~Prog~ and displays it. If it is a ~Bind~, it first takes the ~Prog~ inside, then shows the ~Item~. If an ~Item~ is passed, the same ~Item~ will be returned. Show serves as one of two ways to turn a sequential composition back into a parallel one. This however does not capture any emmited ~commits~. If the execution of sequential composition is desired, ~runner~ should be used instead.
** Making the API more intuitive with macros
Earlier we discussed a possible implementation for our sequential composition, using ClojureScripts ~let~ as an inspiration.
We choose that function, among other things, because it's ~[key value]~ structure is well understood and is much easier to read than nested annoymous function calls. However, to achieve our goal we need to make use of a ClojureScript feature called macros.
*** Why are macros used here?
From now on, the previously defined functions like ~then~, ~return~, ~runner~ will be called primitives. While these enable us to compose sequentially, they don't work like ~let~ does. Listing #15 shows the current usage of ~then~.
#+begin_src clojure
  (then first
	(fn [a]
	  (then second
		(fn [b]
		  (then third
			(fn [c]
			  (done [a b c])))))))
#+end_src
The developer needs to create the annoymous functions by hand, everytime. Thankfully, the functionability of binding ~keys~ to ~values~ stays the same, as results of the components, like ~first~, will be bound to the parameter in the ~continuation~ (e.g the symbol ~a~).
Because this is functionaly identical, we can use a macro to translate the code example above into the desired ~let~ like structure.
*** What are macros?
Macros are a powerful feature which lets us rewrite our ClojureScript code before it's being evaluated. We do this by selectivily telling the language what to evaluate and what to keep for /later/. That allows us to use all of ClojureScripts functions to manipulate the input code. This is made possible partly because ClojureScript is a Lisp, so the code already looks like a datastructure. The language uses this to its advantage to operate on itself. The return value of a macro will be a list of code, that will then be evaluated.
Macros can be found all over Clojure and ClojureScript. Functions like ~when~ and ~when-not~ are macros work in a primitive like ~if~[CD1]. Even the ~let~ function is a macro[CD2].
*** Syntax
The ability to delay evaluation of just some parts of our code is powerful. ClojureScript gives a couple of new symbols to decide how it should evaluate code. We can use these symbols inside of a ~defmacro~ function, which works similiar to ~defn~ and ~def~ which we define functions and values with.
The following table lists the symbols:
| Symbol | Name           | Function                          |
| '      | Quoting        | Stop execution                    |
| `      | Syntax quoting | Like ' but qualify with namespace |
| ~      | Unquoting      | Start execution                   |
If we quote something with ~'~ or ~`~ it will not be evaluated yet[QCEFP1]. The difference between the two is that ~`~ qualifies each expression with their full namespace. The ~~~ symbol turns on evaluation inside of a ~`~ again[QCEFP1].
*** What are the uses cases for macros?
Macros provide so much freedom that they to enhance not just our API but also the language itself. If the problem is beyond manipulating data, but rather about manipulating the functions that are to be used, macros are a good fit.
They allow a developer to provide their API exactly how they imagine it. That's why we will make use of them in our implementation.
However, while things like binding symbols to values under the hood can be used to make things easier for the developer, it can also cause confusion as developers have no idea where the symbol actually came from and can only assume that it works because a macro is used beneath the function. That assumption gives them little information though. They can also lead to confusing error messages, as another step is added before the evaluation. So macros must be used with care, even if they can be a tremendous help.
*** Which macros will be implemented?
Because the structure of ~let~ acts as a dead-end, so too would our ~let~ like structure act as an end for our sequential composition. As such, a macro will be implemented that wraps the ~runner~ primitive and enhances it with the ~let~ like structure. Other macros might be added for easier implementation as well, but are not necessary.
** How parallel and sequential composition interact
The developer should be able to use the API like they use the other tools of reacl-c. At the same time though, there needs to be a clear border between the parallel and sequential composition, as they're fundamentally different. To guarentee that, the API introduced the ~Prog~ and ~Bind~ types. While neither work with other reacl-c tooling (to discourage incorrec usage), both contain an ~Item~. Taking a ~Prog~ and turning it into an ~Item~ is simple, thanks to ~return~. Turning an ~Item~ into a ~Prog~ or ~Bind~ is also simple and can be done with either ~show~ and ~runner~, however the later has little use if the ~Item~ does not emit a ~commit~ at some point. Functionality that could check if an ~Item~ will ever emit a ~commit~ (or other types), would be something to add in the future. Perhaps an additional keyword like ~:state:~ for the ~return~ function of the ~core~ namespace in reacl-c could be added to handle this case.
It's worth mentiong that that at the borders further composition of the type that has been moved away from, isn't possible anymore. A ~runner~ returns an ~Item~ which from that point on can only be meaningfully parallely composed. Likewise, wrapping a ~Prog~ within a ~div~ with other ~Items~ is also meaningless. The developer needs to make a choice at those points if they really are done composing, in order to switch to the different type.
** What is the result of the last continutation?
There are multiple options for what this behaviour could look like. The most obivous answer to the question, of what a ~runner~ will return at the end, is that it will the last ~Prog~ indefinitely. It could also stop displaying anything, though there is little benefit to that.
A more interesting implementation would be to let the developer return whatever they like in the last continuation of the last ~Bind~. So instead of unwrapping a ~Prog~ into an ~Item~ to use with other ~reacl-c~ functions, the ~runner~ could return a normal value at the end. This has the benefit of making out ~runner~ be more, than just a display, which will turn in to a dead end. A possible use-case would be the chaining together HTTP requests where only the result is important.
However useability would suffer, as the developer would need to check if the received value from a ~runner~ is an ~Item~, which should be displayed, or a value, which is to be used for further transformitive purposes.
An extension of this idea would be to allow the developer to pass in a body as the last parameter, much like when ~let~ is used. If a body function is provided, the function is given access to all of the intermediate results of the ~Progs~ in the ~runner~ and the result of the body function is returned. If no body is provided, no result will be returned, the last ~Prog~ will just be displayed indefinitely. Like with the previous implementation, this would also suffer from needing to pattern-match the returned value.
*** Reacl-c gives us more options
In many frontend frameworks these options would be all that is possible, but because ~reacl-c~ allows us to emit actions which propagate up the item tree, we can do more than to just display the result on the screen or have the data be returned from the ~runner~ in it's raw form. Thanks to this, the result of the last continuation could be emitted as an action and be caught by a ~handle-action~ function which wraps the ~runner~. This is not perfect either. One might think that this would mean the pattern-matching might be optional, but it is not. In ~reacl-c~ an action must be caught by something. If it is not and the action reaches the top level item, an error is thrown. By allowing to emit the result it is possible to accidentally send an action upwards, by returning something in the last continuation from within a ~runner~ and to be unaware that this ~runner~ would need to be wrapped by an ~handle-action~ function, because there is no way to warn the developer of this (like with using Exceptions in Java). But, one could argued that using ~handle-action~ to catch the returned value, instead of using a function around the ~runner~, like ~cond~, is more idiomatic, as the developers are already using ~handle-action~ to catch actions in the entire ~reacl-c~ app.

This implementation again could be extended by allowing for the last parameter to be a body function, like with ~let~. If the body function is present, the developer can be sure that the ~runner~ needs to be wrapped by a ~handle-action~. If the ~runner~ is only made up of ~Progs~, the developer does not need to do anything. This makes it possible to clearly express when something needs to be caught, but is open for improvement as it requires additional knowledge about how ~runner~ works. But what would that body function look like? It seems more intuitive to just react to the result in the body function, instead of additionally wrapping the ~runner~ with a ~handle-action~. This implementation also has the problem of not being able to warn the developer that they didn't wrap their ~runner~ with a ~handle-action~.
It does make sense to provide a ~handle-runner~ function which combines this functionality, by taking a ~Bind~ and a function that will handle actions. Actions inside of the ~runner~ won't be returned, but emitted. However, this might be too close to the other implementation and, as a bonus function, cause confusion.
*** Potential Use-Cases
These mentioned options all come with downsides. It is important to look at the use-case of the ~runner~ in real applications, to determine which is suited best for use.
The most obvious use-case is regulating the flow of an entire app. From login, to a dashboard and further. Here what is returned doesn't really matter, as the side-effects that the sequence produces are more important than its result.
If we look at creating a sequence for singular workflow, like adding an item to a shop, the result might be important. Also likely is, that we want to let the app know that something happened (e.g product added, refresh items), which could also be solved by giving access to the result. Just returning or emitting the last result might be too intrusive (as it forces developers to always wrap ~runner~), but the option to supply a continuation as a "body" could work well here, as it allows to react to the result of the last step.
Another use-cases is the conditional loading of data (from a server). Here the result does matter and we need to provide the possibility to react to it. Of-course, the developer could just add another continuation which reacts to it, but that is rather a hack. The ability to supply a continuation as the "body" would be a great fit, too.
*** Determining the best fit
Seeing how all three of our use-cases benefit from having the option to react to the result, the implementation that just display the last ~Prog~ indefinitely or shows nothing - is of little use. Using the actions of ~reacl-c~ is nice, but causes unwanted complication. Giving developers the option to handle the result or ignore it, by passing a continuation as a body, allows for all use-cases to work and causes minimal overhead for the developer. This also mirrors the functionability of ~let~.
This however raises the question what should happen if no continuation is supplied. Should the last Prog be shown indefinitely? From a user experience perspective, it's expected that an action has a reaction, thus it makes sense to not show something indefinitely, but rather display nothing. Another benefit would be that sequential composition is cleaning it self up, after being done.
** Why monads are a good fit
Using monads makes sense because they allow us to abstract the actual logic (e.g. waiting for a ~Commit~, combining ~Progs~) away from the developer while also making it easy to combine steps.
The required functions also are a fit for our API. With the ~>>=~ Operation we give the developer an easy way to further compose their sequential components. ~return~ gives us a new type, which we can use to distinguish our sequential and parallel compositions from each other.
Because we wait for a ~Commit~ to be emitted, we need to take asychronisity into account. Thus we need the previously described tools to build up a blueprint and a specially labeled environment in which that blueprint is being executed in. This is much like monads in Haskell too, where monads can be executed in a ~do~ block.
** Tail Call Optimisation
Neither Java nor JavaScript, the two host languages for Clojure and ClojureScript respectively, feature Tail Call Optimization (TCO). Due to the high amount of nested function calls it is however a very important feature for a functional language. With a correct implementation of Tail Call Optimisation it is guarenteed that successive invocations of a monadic bind won't cause a stack overflow. It can also enable the use of recursion with our bind elements. Lastly, with composition it would undesirable to have to worry about depth of composition.
It is therefore important to abstract away the bind logic from the developer, to implement some kind of TCO around it.
*** TCO in ClojureScript
While ClojureScript isn't offering TCO out-of-the-box for every function call, it does provide the ~loop~ and ~recur~ functions which do a locale re-write of the code into a loop.
Another way to gain TCO is to use whats called a trampoline. Instead of stepping deeper and deeper into nested function calls, the function is called once and the result, which is a function, is saved. Now in a loop, the resulting function will be called and each invocation will return another function. This is done until a certain condition is passed and the loop ends. The idea is to pull our function call up, instead of going deeper.
*** Custom TCO
While ~loop~ provides a perfectly fine way to get the benefits of TCO for synchronise functions, in order to work with the asynchronous, action driven, approach that reacl-c uses, a custom implementation needs to be to be developed. We will revisit the concept of the trampoline again during the implementation.
* Implementation
Previously we have discussed which functions our API should offer, now we will focus on implementing these individual functions and features. Being Aside from being functioning, we will also talk about optimizing the ~runner~ function and implementing macros for easy of use.
** then
Discussed earlier, the ~then~ function needs to compose steps together. The basic idea is trivial. Take a ~Prog~ and a ~continuation~ and return a ~Bind~, which is nothing but a container ~record~ type that holds both of these values. Listing #15 shows the definition of a ~record~ type as well as the ~make-bind~ function.
#+CAPTION: Record definition of the bind type and a helper function to filter out incorrect values
#+begin_src clojure
  (defrecord Bind [prog continuation])

  (defn make-bind [prog continuation]
    {:pre [(prog? prog)]}
    (->Bind prog continuation))
#+end_src

However, just passing a ~Prog~ everytime would be of little use. A ~Prog~ just contains a single step. Things get interesting if we want to pass a ~Bind~, because we cannot just wrap the ~Bind~ again, as it already contains a ~Prog~.
If that is the case, ~then~ needs to change the order of execution, to prevent undesirable nesting inside of the ~Bind~. We want our ~Prog~ part of the ~Bind~ to always be shallow for optimization and book-keeping purposes (see Optimization). Thanks to the earlier mentioned Law Of Associativity for monads, we can use CSP transformations to easily change our previous continuation into something that gets rid of the nested calls. This is done by taking the ~Prog~ from the passed ~Bind~ and using it again as our new ~Prog~. The new continuation is an anonymous function which constructs another ~Bind~, by calling the continuation of the passed ~Bind~ with whats passed to the annoymous function (to create a ~Prog~) and using the passed continuation as the actual continuation of the second bind. A visual explanation can be seen in Figure #15.
#+CAPTION: ~Prog 1~ is lifted from the passed ~Bind~. The new cont is a ~Bind~ out of the previous cont and the passed cont.
#+ATTR_LATEX: :width 200px
[[./images/csp-transformation.png]]
This allows us to avoid having to flatten the ~Bind~ anywhere else, which makes showing the ~Item~ inside of the ~Bind~ (and ~Prog~) trivial. It also guarentees that the order of execution will always be correct, thanks to deconstructing the passed ~Bind~ completely.

Now, inside of our ~then~ function we need to handle both cases. For this we differenciate between a ~then~ call where a ~Prog~ is passed and where a ~Bind~ is passed. If a ~Prog~ is passed, we just wrap the parameters and return a ~Bind~. If however a ~Bind~ is passed, we do our CSP-transformation. See Listing #15 for the code.
#+CAPTION: Definition of the ~then~ function using csp-transformation
#+begin_src clojure
  (defn then [prog cont]
    {:pre [(or (bind? prog) (prog? prog) (c/item? prog))
	   (fn? cont)]
     :post [(bind? %)]}
    (if (bind? prog)
      (make-bind (bind-item prog) (fn [x] (then ((bind-continuation prog) x) cont)))
      (make-bind (if (c/item? prog) (make-prog prog) prog) cont)))
#+end_src
To give the developer feedback in case they make an error, we add ~:pre~ and ~:post~ annotations, which let ClojureScript know to check the types that come into and out of our functions. In this case we say that the ~prog~ can be a ~Prog~, ~Bind~ or even an ~Item~. The ~cont~ parameter needs to be a function and the result of our operation should always return a ~Bind~.
** runner
The place for our monad to be executed in is the ~runner~. It will receive a ~Prog~ or ~Bind~. The ~runner~ is the most complex function of our API because of all the things it needs to do:
1. Book-keeping of state for steps
2. Catch emitted ~Commits~
3. Make sure implicit state is passed to the ~Prog~ (without leaking own state)
4. And optimize function calls to prevent stackoverflow
As such we will show the code in its entirety here and go in depth about individual parts one after another. See Listing #15 for the code.
#+CAPTION: Entire definition of the ~runner~ function using trampolines, state-management, lenses and actions.
#+begin_src clojure -n 0
  (defn runner [b]
    {:pre [(or (bind? b) (prog? b))]}
    (c/local-state
     b
     (c/dynamic
      (fn [[_ inner]]
	(c/handle-action
	 (c/focus
	  first-lens
	  (show inner))
	 (fn [[outter st] ac]
	   (if (and (commit? ac) (bind? st))
	     (c/return :state [outter ((bind-continuation st) (commit-payload ac))]))))))))
#+end_src
*** Basic Functionality
The goal of the ~runner~ is hold and display whats inside of a ~Bind~. While it does this, it wraps the ~Bind~ and waits for a ~Commit~ which will trigger the it to call the ~continuation~ of the ~Bind~.
To understand this better we're going to focus on line 5-13 of Listing 15. First notice the ~handle-action~ call. This function takes two parameters. First an ~Item~ to display, second a ~function~ to call once the ~Item~ emits something. The function that will be called can be seen at the bottom on line 11-13. We don't directly pass an ~Item~ however. We pass a ~focus~ function. This is done to ~focus~ the state on a specific part. Namely limiting the implicitly passed state to whats outside of the runner, instead of leaking the book-keeping state of the runner downwards. This function again takes two parameters. First a lens (function of two arities) and second an ~Item~. We will talk more about the lense later.
The second parameter the in our API defined ~show~ function, which just takes either ~Bind~, ~Prog~ or ~Item~ and unwraps it to an ~Item~ again.
From this point on we can talk about the ~function~ that was passed to the ~handle-action~. That function has two parameters again. First is the state of the ~runner~ at the moment at which the action was emitted from the ~Item~. We have access to this so we can reduce the state with the second parameter, the action send from the ~Item~ to us, into a new state. We then return that new state with the ~return~ function (using the ~:state~ keyword). This lets the component know that it needs to update its state, therefor render itself again. The passed state is destructured into the outter state, which was implicitly passed to our ~runner~ and the state of the ~runner~ itself (here ~st~). In line 12 we have a check confirm the ~Item~ sent us an action that is a ~Commit~. If it isn't a ~Commit~, the action will propegate further upwards. We also check if our current state holds a ~Bind~, because only if we have a ~Bind~, can we call a ~continuation~. In line 13 we then call the ~continuation~ of our ~Bind~ with the payload of the ~Commit~ and return it as state of our ~runner~.
*** Lens
The previously mentioned lens in line 9 is needed to stop leaking the book-keeping for our tail call optimization, downards into our ~Item~.
Lenses are a popular mechanicsm in functional programming to, on one side, restrict the available information, while allowing changes from the restricted side to change the whole, as well.


Our lens is a first lense, because it restricts access to anything but the first element. This is releveant because when state is passed around inside of a component in reacl-c, it usually comes in the form of an array where the first element is the outter and the second parameter is inner state.

The code for the first lens can be found in listing 16.
#+CAPTION: Code for the first-lens.
#+begin_src clojure
  (defn first-lens
    ([[first & _]]
     first)
    ([[_ & rest] small]
     (vec (cons small rest))))
#+end_src

Because we don't want the internal state of our ~runner~ to leak, but we do want the state surrounding the ~runner~ to be passed down, we ignore the inner state and pass down the outter.
Our lense is a function with multiple arities. That means it can take different amounts of parameters. Ours being of aritiy of two, means it has two different signatures. A signature where it gets one parameter and a signature where it takes two parameters.
To restrict access, so when it is called from the perspective of the child, the signature with one parameter is called. Here the list inner, outter and what else is destructured and everything besides the ~first~ element is ignored. That ~first~ element is then returned.
On changes to the state from within our child, the signature with two parameters is called. The change being the second parameter, here called ~small~. We again destructure the first argument but now ignore the previously named ~first~ and access the previously ignored ~rest~. All that is left is to combine them with ~cons~ and return them as a ~vector~.
*** Implementing Tail Call Optimization
Previously we discussed what TCO is and why we want it. Now it is time to take a deeper look at how we implement it by examing line 2-5 and 10-12 in listing 15.

Like mentioned earlier ClojureScript already provides TCO with the ~loop~ macro, unfortunately we can't take advantage of it because of the asychronos nature of reacl-c. This is not a problem as we can use the previously explained concept of trampolines to make our own TCO.

The basic idea is to save the ~Bind~ in our state and update the state each time a ~Commit~ comes in, with the result of the ~continuation~ of our ~Bind~. This works as follows in detail:

In our ~runner~ we define ~Bind~ that was passed into the function as local state using the ~local-state~ function. This is the first part of our trampoline. Next we call ~dynamic~, which takes a function that has one parameter. That parameter will be the state of our component, which is why we destructure it in line 5 to ~outter~ (which is immidialty discarded with ~_~) and ~inner~. This is clever, as we now have access to the state of our ~runner~ component, through the parameter of the function. We need to access state, because we want to both display the ~Bind~ and wait for it to ~emit~ a ~Commit~ (using the ~handle-action~ function).
Now, in line 10, we define the function that will be called once an action is emitted. Like mentioned earlier, if the action is a ~Commit~, we execute the code in line 12. Here we set our state to the result of the ~continution~ of the ~Bind~ of our ~inner~ state, completing our trampoline. Because we set our state, the component will be render again, this time with the updated state, which is the next step in our sequential composition, because it is the result of the ~continuation~ of our ~Bind~.
** show
To display our sequential composition we can use the ~runner~, if we however just want to display one step (indefinitely), we can use ~show~. This is a simple helper function that is used inside of the ~runner~ to display the ~Bind~. At it's core it has ~cond~ call, which allows us to react to specific conditions. This is necessary, because if we get an ~Item~, we can just display it. If we get a ~Prog~, we need to unwrap the ~Item~ from it. If we get a ~Bind~ we first need to get the ~Prog~ inside of it, before we again can unwrap it. Lastly, to make usage easier, if anything else is passed, we display an empty ~fragment~, which is equavialent to nothing. Getting passed neither ~Prog~ or ~Bind~ is the case after finishing the last ~Bind~. See listing 25 for the entire code of the ~show~ function.
#+CAPTION: Code for the ~show~ function.
#+begin_src clojure
  (defn show
    [x]
    {:post [(c/item? %)]}
    (cond
      (prog? x) (prog-item x)
      (bind? x) (prog-item (bind-item x))
      (c/item? x) x
      :else (c/fragment)))
#+end_src
** Macros
The available primitives already enable the developer to craft elaborate sequential composition, whoever they aren't able to provide ~let~ like usage on their own. For this reason, we will implement macros for our API. Only a macro version of the ~runner~ is required, but it makes more sense to enhance the ~then~ primitive first and later wrap the ~runner~ with something that takes advantage of the ~then~ macro. Before we dive into the macros themselves, we first need to take a look at how macros work in ClojureScript.
*** Setup
Both Clojure and Clojurescript have access to macros, though implementing one is more complex in the later. This is because of the compilation process. Macros are run during compile process of ClojureScript. This means the compilation process needs to be kept in mind when writing ClojureScript macros. You cannot, for instance, put macros in a ~.cljs~ file because of this.
Regardless, it is still possible to both write Macros for ClojureScript and write Macros that use ClojureScript code.
There are multiple ways to write a Macro for use in ClojureScript. The easiest would be to write the necessary code in a ~.clj~ (instead of a ~.cljs~) file and importing the macro by pointing the ~:require-macros~ keyword to the namespace defined in the ~.clj~.
#+CAPTION: Example definition of a macro in ~macros.clj~
#+begin_src clojure
  (ns code.macros)
  (defmacro example-macro [x] (code.other/function x))
#+end_src
#+CAPTION: ClojureScript file ~actual.cljs~ that imports the previously in ~macros.clj~ defined macro with ~:require-macros~ keyword
#+begin_src clojure
  (ns code.test
    (:require [code.other])
    (:require-macros [code.macros :as m]))
  (m/example-macro "example")
#+end_src


Listing 13 and 14 show how to both create and import a macro. They also show how a macro can be defined in Clojure, that needs to access ClojureScript code. The important addition is that the source of the macro needs to specify the function with its entire namespace. Namespaces that want to use the macro need to also require the namespace specified in the macro (in our case the ~code.other~ namespace). It's advised to create another namespace that abstracts this work away by providing both the needed namespaces and the macros.
*** then
The goal of our macro is to rewrite the passing of multiple ~Progs~ into a series of ~then~ calls, which then bind the result of each step to a symbol. Like with Clojures ~let~, we want to pass a list of ~(symbol,value)~ pairs to our macro. Internally the macro will change this to functional ClojureScript code.
#+CAPTION: The macro will take care of wrapping ~Progs~ in a ~then~ and creates an annonymous functions each time (while binding symbols to function parameters)
#+begin_src clojure
  ;; Before macro
  (runner (then prog1
		(fn [x]
		  (then prog2
			(fn [y] prog3)))))

  ;; After macro
  (runner [x prog1
	   y prog2] prog3)
#+end_src
Listing 20 hints at what needs to be done. The strategy will be to generate the anonymous functions ourselfs and to use the supplied symbols (in our case ~x~ and ~y~) as the parameters of our newly generated anonymous functions. This is possible because we need to supply a ~continuation~ to our ~then~ anyways. That ~continuation~ can have any amount of parameters, but for this to work we only need to give one. Listing 21 shows the macro in it's entirety. The core idea of the implementation is heavily influenced from Konrad Hinsen's blog post "Monads in Clojure"[KH1].


#+CAPTION: The entire macro that wraps our ~Progs~ with ~then~ and generates the annoymous functions
#+begin_src clojure -n 1
  (defmacro then
    [[var val & rest :as steps] end-expr]
    {:pre [(even? (count steps))]}
    (if steps
      `(code.bind/then ~val (fn [~var] (then ~rest ~(seq end-expr))))
      end-expr))
#+end_src

Our macro takes two arguments. A list of values and an end expression, just like ~let~ does. The list of values is then destructured into three parts. ~var~, ~val~ and ~rest~. The ~var~ will be our symbol, ~val~ the value our ~var~ will be associated too and ~rest~ is whats left of our list.
After making sure that our list is balanced, meaning it has just as many ~vars~ as ~vals~, we check if we have ~steps~ left. ~Steps~ is just a reference to our ~var~ and ~val~, as well as ~rest~. If that's the case, we stop execution of our code with the ~`~ symbol and begin to build the macro part of our function. We want to call the primitive ~then~ from our ~bind~ namespace, like mentioned earlier, to do this we need to spell out the entire namespace, as we're currently in a ~.clj~ file and cannot import the ~.cljs~ namespace.
Our primitive ~then~ takes two parameters. First a ~Prog~ and second a ~continuation~ function. We use the ~~~ symbol to pass undo the syntax quote and pass the ~val~ as is. Then we continue and build our anonymous functition. For our macro to work just like ~let~ we need to pass our ~var~, which stand for our symbol (e.g. ~x~ and ~y~ earlier), as the parameter of our anonymous function.
Inside of our function we then do a recursive call to our macro, once again undoing the syntax quoating to pass the ~rest~ of our list and our ~end-expr~ (which is wrapped by a list, to stop it from being executed). Our ~end-expr~ will be executed once we've worked through all ~steps~. Important to remember is that ~end-expr~ itself might try to access the symbols given in to our ~then~. This will work, because ~end-expr~ is at the bottom of all of our anonymous functions, which provide the context in which these symbols are bound to values.
See listing 22 to see how the nesting of anonymous functions works out, to allow ~end-expr~ to have access to the symbols.
#+CAPTION: Example of where ~end-expr~ will be executed
#+begin_src clojure
  (then prog1
	(fn [x]
	  (then prog2
		(fn [y]
		  (then prog3
			;; Assuming end-expr accesses x y z
			(fn [z] (end-expr)))))))
#+end_src
Now our ~then~ macro can be called exactly like we would with ~let~, simply by doing the following:  ~(then [a prog1 b prog2] (fn [] (+ a b)))~ we are able to chain together ~prog1~ and ~prog2~. What we get back is a ~Bind~ of the both ~Progs~.
*** runner
With our ~then~ we have greatly improved the desired developer experience, however, the result still returns a ~Bind~. That is fine, as we might want to further compose this. However, if we want to use our sequential composition we still need to wrap our ~then~ expression with a ~runner~ to run it. To further simplify the experience we will create another macro, this time for the ~runner~ function, to give developers the option to do everything within a single call.
For this we will simply wrap our ~then~ macro with our primitive ~runner~ from the ~bind~ namespace. Again we syntax quoate our call and undo the quote for our values. To add even more convienence our ~runner~ macro has an aritiy of two. If the developer is not interested in supplying an ~end-expr~ function, we will pass an empty function for them. The resulting code is simple but works and can be seen in listing 24.
#+begin_src clojure
  (defmacro runner
    ([x]
     `(runner ~x (fn [])))
    ([x y]
     `(code.bind/runner (then ~x  ~y))))
#+end_src
** Limitations
While the current implementation achieves what it set out to do, some compromises had to be made. First, like mentioned earlier, it is being relied on the fact that the developer actually emits a ~Commit~ in what they label a ~Prog~. Sadly, there is currently no logic to make sure that the developer is forced too or reminded if they aren't.
Another limitation is that a ~runner~ is a dead end for sequential composition, as it is only further composible in parallel. Further more, the current API offers only primitives and none of the deep functionality which is present in reacl-c for the parallel composibility. So functions that map, filter etc. over sequential compositions are not included. There is also no error handling for sequential composition. Developers need to handle errors by hand in the continuation of the next ~Bind~, as there isn't an ~Error~ sub-type of ~Commit~. Lastly, there is no way to terminate early, like a ~Maybe~ monad.
* Examples
With our API now defined and implemented we can take a quick look some examples, to see if we have improved the developer experience.
** Sign-up component
Our initial example, to explain what sequential composition is, was a sign-up component. That makes sense because modern sign-up processes are often split up into parts. Lets build that three step sign-up process again, this time with our API.
#+CAPTION: Example usage of our API for the sign-up process shown in the "Motivation" chapter
#+begin_src clojure
  (runner [personal (return personal-info)
	   code (return verification-code)
	   _ (done [personal code])])
#+end_src
Listing 25 shows the sequential composition. We wrap the components before passing them. If the developer knows that the item will only be used in a sequential composition they can of course also use ~def~ and wrap their ~Item~ inside with a ~return~.
The only necessary change inside of our components is to emit a ~Commit~. See listing 26 for this, where we change the behaviour of the ~personal-info~ component.
#+CAPTION: Excerp of the ~personal-info~ component. Parts have been removed for clarities sake. This is a parallel composition that emits a ~Commit~ once the user presses the button.
#+begin_src clojure
  (c/def-item personal-info
    (c/local-state
     {:name "" :email ""}
     (c/dynamic
      (fn [[outter inner]]
	;; Input code ...
	(dom/button
	 {:onclick (fn [state action] (c/return :action (bind/make-commit inner)))}
	 "Continue")))))
#+end_src
This is all that is needed to create our sign-up process. The ~runner~ can now be placed into a parallel composition.
** Endless loop
Because our ~then~ takes a ~continuation~ for its next step, it's trivial to create an infinite loop. Our macros make this trivial even easier, by abstracting boilerplate code away from us. And because our ~runner~ implemented TCO, we can be sure that our stack won't blow, no matter how often we have looped. Listing 26 shows an example of an infinite loop using our macros.
#+CAPTION: Example of infinite loop using macros
#+begin_src clojure
  (defn infinite-loop [n]
    (m/runner [a (item n) ;; helper function which creates Prog
	       _ (infinite-loop (inc a))]))
#+end_src
It could be possible that there are even conciser methods possible, however this implementation is small enough for now. Worth of note is that the recursive call still receives an integer from the previous step. Also, because this loop never ends, the developer can use ~_~ to ignore its result, like they would also do with a function parameter.
** Repeatable workflow
In the previous example we saw the benefit of using recursion in our ~runner~. Let's push this further by going beyond a single step. Some software systems are nothing but an endless loop of the same operations. Ordering processes like vending machines come to mind. These are now trivial to create (and enhance) thanks to our sequential composition.
Let's take a disease testing facility as an example. We're going to model the following steps:
1. Enter personal information of patient
2. Select test type and start test
3. Enter test result
4. Print, showcase or send result to patient
Our sequential composition for this process can be seen in listing 27. Noteworthy would be the option to pass the collected information further along, which could be used to collect statistics (e.g for positive cases etc.).
#+CAPTION: Example of system for testing of disease
#+begin_src clojure
  (defn test-patient-for-disease []
    (m/runner [personal-info aquire-personal-info
	       test-info enter-test-info
	       result enter-test-result
	       _ (showcase [personal-info test-info result])
	       _ (test-patient-for-disease)]))
#+end_src
* Possible improvements
While it can be argued that our API does what it set out to do, there are a various ideas that had been discarded, to spend more time improving the core of the API.
During the implementation of the runner the idea for early termination came up. Similiar to something the ~Maybe~ monad, developers could throw a different type of ~Commit~ to tell the chain to break. Inside of the ~runner~ the developer then would have the option to handle the early termination. Wheter this could be done by adding a third parameter, or by giving a different kind of ~runner~ is yet to be determined. However, giving developers the ability to break the chain at any time could lead to problems, as, much like with ~Progs~ actually firing ~Commits~, we can't communicate to the developer that this ~Prog~ might terminate early. This could be solved by making a dedicated type, that only works with a sub-set of operations, but is also a lot of work.
But, not just a seperate type for terminating early could be interesting. Having the ability to communicate that an error has occured and being able to handle that (maybe even in different steps of severity) would be beneficial. Imagine if a lot of time has passed since step 1 and step 2 and the user gets logged out. Instead of having to handle the error either outside of the ~runner~ or inside of every step, we could dedicate a space inside of the ~runner~ for that.
Besides new types, another improvement would be to force a developer to ~Commit~ something inside of a ~Prog~. The implementation for this is unclear, however the feature is highly important as it could be a major source of bugs.
Lastly, helper functions for sequential composition, like the ones that exist in reacl-c for parallel composition, could be a possible addition. Things like a ~def-prog~ function that works like ~def-item~ but also wraps the resulting ~Item~ inside of a ~return~. Or the ability to map actions emitted from a component, to be ~Commits~, so the actual component doesn't need to be changed, but can still be used inside of a sequential-composition. There are problaly many more applications of the deep pool of functions inside of reacl-c, so these are just some that had been found.
* Conclusion
Having used our API to build the earlier mentioned examples, it is clear to us that our implementation delivers what it set out to do: Enable sequential composition in a developer friendly way. Creating sequences of steps is now much easier and composible. Despite all of the work happening under the hood, from tail call optimization to handling the asychronosity, the developer can use the API without being ever bothered by either. At the same time usage is dead easy, thanks to taking an already well understood way of working with data, like with ~let~, as an inspiration.
While the API could be enhanced, the added complexity of some proposels could also take away from the current present simplicity. It's best to first see how the current implementation solves the problem presented by workflows, before making big additions.
We're pleased with the implementation and are excited to find out what we can build with it.
* Sources
- [CD1] https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L493
- [CD2] https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L4481
- [QCEFP1] Quick Clojure: Effective Functional Programming - 10. Macros
- [RC1] https://github.com/active-group/reacl-c/blob/0.10.10/src/reacl_c/core.cljc#L94
- [KH1] https://github.com/khinsen/monads-in-clojure


