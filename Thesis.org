#+TITLE: Composition of UI elements in reacl-c using monads
#+AUTHOR: Marlon Schlosshauer, Applied Computer Science, Hochschule Offenburg
#+LANGUAGE: english
#+OPTIONS: \n:t
#+OPTIONS: toc:nil
#+OPTIONS: broken-links:auto
#+LATEX_HEADER: \hypersetup{colorlinks=true, linkcolor=black}

#+LATEX: \newpage

* Acknowledgment
:PROPERTIES:
:UNNUMBERED: t
:END:
I'd like to thank some of the many people that supported me while I was writing this thesis.
First of all I'd like to thank my supervisor, Markus Schlegel, for not only providing many of the ideas found in this thesis, but also sharing his vast knowledge of function programming and reacl-c.
I'd also like to thank the Active Group GmbH for making this thesis possible. I'm very thankful and happy that I got to explore such an interesting topic.
Lastly I'd like to thank my professor, Prof. Dr. Stefan Wehr, for introducing me to the Active Group GmbH and also giving helpful answers to my questions.
#+LATEX: \newpage
* Abstract
:PROPERTIES:
:UNNUMBERED: t
:END:
As the need for digitalisation of workflows grows, so does the importance of the tools that we use to create them. The composition of UI elements has been a necessary tool in the process of creating UIs and is, as a result of that, well supported in modern frontend developments. We however propose that composition of UI elements can be split into parallel and sequential composition. The former is what we commonly understand when we talk about composition of UI elements: The ability to say which elements belong together on the screen, at the same time.
The latter is a different kind of composition that allows us to express in which order those parallel compositions are shown. This is significant because workflows are made up of individual steps that have a predetermined order to them. However, the current support to build and mantain these kinds of structures, despite that importance, is poor.
In this thesis we will examine the difference between parallel and sequential composition, go into detail about why sequential composition is important, look at examples of current support for our new kind of composition (or lack thereof) and explore a developer friendly API for it.
Furthermore, we show what real-c is and compare it to React, before implementing the previously proposed API in it. At the end we give examples of sequential composition using our implementation and discuss possible improvements.
#+LATEX: \newpage
* Zusammenfassung
:PROPERTIES:
:UNNUMBERED: t
:END:
Mit wachsendem Bedarf an Digitalisierung von Arbeitsläufen steigt auch die Bedeutung der Werkzeuge, welche wir für die Entwicklung dieser verwenden.
Die Komposition von UI-Elementen ist ein notwendiges Werkzeug bei der Erstellung von UIs, weswegen es in modernen Frontend Frameworks wie React und Angular auch gut unterstützt ist. Wir schlagen jedoch vor, dass die Komposition von UI-Elementen in eine parallele und sequenzielle Komposition unterteilt werden kann. Ersteres ist, was wir allgemein unter Komposition von UI-Elementen verstehen: Die Fähigkeit auszudrücken, welche Elemente gleichzeitig (parallel) auf dem Bildschirm angezeigt werden.
Letzteres ist eine andere Art der Komposition, welche es uns ermöglicht, die Reihenfolge der zu anzeigenden (parallelen) Kompositionen zu bestimmen. Dies ist wichtig, da Arbeitsabläufe aus einzelnen Schritten bestehen, die eine genaue Reihenfolge besitzen. Allerdings ist die derzeitige Unterstützung für den Aufbau und die Weiterentwicklung dieser Art von Struktur trotz ihrer Bedeutung gering.
In dieser Bachelorarbeit werden wir die Unterschiede zwischen paralleler und sequenzieller Komposition vorstellen, die Wichtigkeit von sequenzieller Komposition veranschaulichen, sehen wie momentan diese Art von Komposition implementiert werden kann und eine entwicklerfreundliche API dafür entwerfen.
Darüber hinaus zeigen wir, was reacl-c ist und vergleichen es mit React, bevor wir die zuvor entworfene API darin implementieren. Am Ende geben wir Beispiele für sequenzielle Komposition in unser entwickelten API und sprechen über mögliche Verbesserungen.

#+LATEX: \newpage
#+TOC: headlines
#+LATEX: \newpage

* Motivation
Components are an important tool in modern frontend development. In traditional frameworks we can define something as a component to reuse it multiple times in our applications, encapsulate some style with some functionality or collect multiple elements into a single component. To be more precise, we can compose things in parallel because we can group elements into something that is to work together. An example of a parallel composition would be two input fields and a button, which together define a sign-in component.

#+CAPTION: Example of parallel composition of a sign-in component. The first composition is the result of adding a button and two inputs. We further compose the first composition by adding a headline. That result is then again further composed by adding a logo.
#+ATTR_LATEX: :width 350px
[[./images/parallel-composition-highlighted.png]]

However, modern frontend applications have gone beyond just serving information with HTML. Websites often act as a digitalization of a workflow, where the order of components, as in which component is shown after another, is crucial. This is also a kind of composition. Instead of composing things in parallel, we're composing sequentially here. That is to say, we say which steps we have and in what order they appear. Together they form a sequence.
It is important to point out that the here mentioned sequentiality is different from how we might know it from imperative programming (IP). In IP, sequentiality is used, even if the domain doesn't demand it, because of its writing style. We could call this accidental sequentiality, as it is only a by-product of language design and history, rather than a conscious engineering decision.
Because our sequential composition exhibits natural sequentiality (e.g first step ~A~, then step ~B~) we also want to represent that in our code.
An example of a sequential composition would be to first ask the user for their email address, then, after having the user enter a valid email, show another input field, where the the user can enter a code that was sent to them, using their email. Notice that the second step can depend on information that was gathered by the previous step.

#+CAPTION: Example of sequential composition of a sign-up component. The first composition combines two steps, before being again further composed by adding a third step.
#+ATTR_LATEX: :width 350px
[[./images/sequential-composition-highlighted.png]]

Because of this dependency, composing sequentially isn't just an optimization. It is a fundamental building block of how an application is supposed to operate. Just like how we need the ability to show both an input field and a button at the same time (to confirm the input), we also need the ability to model what happens after (and possibly before) that button has been pressed.

But despite that need, the actual support for sequential composability by modern frameworks is either non existent or very poor.
While some of the desired result can be achieved by making clever use of parallel composability or using traditional links, most aren't truly sequentially composable and both suffer from multiple issues, some of which are:
- They don't yield things which we can compose further (into more sophisticated workflows)
- Reusing these components leads to a lot more boilerplate
- It produces code that becomes difficult to understand at a glance (or at all)
- Logic for advancing steps (and bookkeeping) live besides the parallel composing logic
- Bookkeeping is scattered throughout the codebase
There are more issues. The inability to easily test just the order of the components and the huge time cost required to refactor constructs of this nature are just the starting point.

Our applications already are a collection of parallel compositions. If we add the ability to compose sequentially, we gain another tool to control our programs. Not only would our code be more expressive and more concise, bugs could also be reduced because the resulting systems represent more truthfully what they set out to do, thanks to the provided API of the framework. Most importantly, we could build workflows out of smaller flows or other workflows entirely and share these across our applications, just how do with our UI elements.
Given the lack of support and the possible applications it is of high interest to find a way to compose sequentially, easier.
* What is React
React[1] is a popular UI framework developed by Meta (formerly Facebook) and is written in JavaScript. Like other modern JavaScript frameworks, it is a Single-Page-Application (SPA), which means the entire application is loaded and available after visiting a single page. Instead of having each page defined in HTML, developers are able to define all pages in JavaScript, using Reacts JavaScript Syntax Extension (JSX). React takes those JSX definitions and builds HTML accordingly, before adding it to the browser's DOM.
#+CAPTION: Example of JSX to define a profile component
#+begin_src javascript
  const profile = ({name, age, image}) => {
      return (
	  <div className="profile-container">
	    <div className="profile-info-container">
	      <p>{name}</p>
	      <p>Age: {age}</p>
	    </div>
	    <img alt={`Avatar of ${name}`} src={image}/>
	  </div>
      )
  }
#+end_src

An advantage of a SPA design is that commonly used components, like a header and footer, can be shared over multiple pages without having to be retransmitted, as the JavaScript code is still in memory inside of the client's browser. In such a system navigation does not mean the browser is navigating to another page, but rather it tells React to build the desired next page from the JSX definitions already present on the client. Besides requiring less bandwidth on successive visits, this also leads to better response times on page visits after the initial load, as those pages are also already in memory. The downsides are that the client needs to compute the page by executing JavaScript to build it and the longer initial load times associated with this computation.

Another important feature of React is that the developer must explicitly declare the state of a component. This is used to improve performance, as only components which are effected by a state change are rendered upon changes. Old components remain untouched. This also helps with identifying where state is and how it might be changed in the future.

React is also a popular basis for other frameworks like Preact. It is especially popular for ClojureScript based frameworks. Noteable examples are reacl-c, om, reagent, rum and others.
* What is reacl-c
Reacl-c [2] is a UI framework for ClojureScript that is designed to make the composition of UI components easier. Like other ClojureScript frameworks, reacl-c wraps React to best take advantage of Clojure's immutable data structures. Like React, reacl-c allows the definition of components, called ~items~. These ~items~ can have child ~items~, thus forming a tree, just like components do in React.

To make composing of ~items~ easier reacl-c takes a different approach to state than React. There are two types of state. Local state, which is defined inside of the component and outter state, which is implicitly passed down from the parent to the child. The later has the unique feature of putting the emphasis on the parent, in their relationship. We will explore why this is important soon.

Another key difference to React, is that ~items~ can emit actions if an event occurs inside of them. These actions propogate upward the item tree. Every item can register an action handler, which captures the action and reacts to it. This enables the developer to define a (child) ~item~ completely independently from their potential future parents, leading to more reusable and more composable components.
Instead of having the parent pass down a function to, e.g manipulate state, the component can emit an action upwards and trigger the same functionability in the parent. Another benefit is that the parent component can adapt the output of the emitted action further.

#+CAPTION: Showcasing the inversion of control by comparing emitting of actions to passing down callbacks. Each circle represents a component. To communicate the callbacks need to be passed down. With actions, the children can speak up on their own.
#+ATTR_LATEX: :width 350px
[[./images/emit-vs-callback.png]]

As an example: A button toggles an option flag from ~true~ to ~false~ and back. The state for this option is put into the parent, our button is a toggle component which will be reused across the application. In React, the button needs to receive a function which to callback, after the button has been pressed. In reacl-c the button does not need to receive anything from the outside world, as the button emits an action when pressed, which the parent can capture and act upon.

The action system in reacl-c is inspired by the functional programming concept of effect systems. An effect system allows code to express effects, by tracking them directly through the type system[x]. Like an effect system, the action system in reacl-c allows us to express these effects by returning either the ~Action~ or ~Return~ type.  
#+CAPTION: We create an item called ~abstract-button~ which contains a button. If pressed, it's going to fire an ~:action~ with the value ~:pressed~ to it's parent.
#+begin_src clojure
  (defn-item abstract-button [text]
    (dom/button {:onClick (fn [] (core/return :action :pressed))} text))
#+end_src
With this style of communication, only the parent needs to know the child. The developer does not need to tell the child where to send the action. Reacl-c takes care of that work for us.

To make components even more composable the parent can not just control the result, it can also control which state is given to its children in the first place. The parent can therefor handle the child items like they're pure functions, that together with the parent compose to a new item.

In React often another package like Redux is used to fix the problem of having to pass-down functions. Instead of saving all state in each component, state can be managed at a central point which components can send messages to, causing the central state to change. This can cause issues with the composability of components. The problem with this approach is that components cannot be placed multiple times into the app, without making sure they don't all work on the same central state, first. Reacl-c solves this issue by allowing any component to send and receive messages. Not only does this allow for local reasoning, but it also enables us to wrap a component with an action handler and placing it infinitely in the app without worry, as the component won't effect anything outside of that handler.
** How an Item is made
Reacl-c is made up of so-called ~items~ and functions which operate on these ~items~. Much like in React, these ~items~ are instructions that represent HTML elements that can be nested and can hold state.
To make an ~item~ reacl-c provides a namespace called ~dom~ that contains all the necessary DOM HTML components already defined as ~items~. As an example, all that is needed to create a headline is ~(dom/h2 "Headline")~. To make more complicated ~items~, combinators like ~(dom/div)~ or ~(core/fragments)~ can be used. These can contain multiple items. See listing 3 for an example.
#+CAPTION: Showcasing composition of multiple ~items~ into one by using a ~div~.
#+begin_src clojure
  (dom/div
   (dom/h2 "Hello")
   (dom/p {:class "subtitle"} "This is some text")
   (dom/button "Subscribe"))
#+end_src
There are other functions which, much like ~div~, don't add something visually but change the behavior of the ~item~. Functions like ~core/focus~, ~core/dynamic~ and ~core/handle-actions~, to just name a few. We will take a closer look at each later.

Behind the calls to the ~dom~ namespace are ~Item~ constructors, which can also receive a ClojureScript ~map~ as their second argument. With this ~map~ things like CSS classes and inline-style can be applied. If the ~Item~ is interactive, like Buttons and Inputs are, the keywords ~onChange~ and ~onClick~ can be used to register a callback.
** Emitting and handling actions
Actions are an important tool for children to communicate with their parents. Like the implicit (or explicit) passing of state from the parent, this is a crucial feature to make items composable.
To emit an action the child needs to call ~core/return~ with the ~:action~ keyword and the desired payload. The action will travel upwards until it is caught by a ~core/handle-action~. The action handler function takes two arguments. First an ~item~ to wrap and receive actions from. Second, a function that defines what do to when it receives an action.
#+CAPTION: The action emitted by the buzzer ~item~ is caught in the parent ~item~ using ~core/handle-action~.
#+begin_src clojure
  (def buzzer
    (dom/dom
     (dom/h3 "Press buzzer to notify parent")
     (dom/button {:onClick (fn [] (c/return :action true))} "Buzzer")))

  (def parent
    (core/local-state
     {:pressed? false}
     (core/handle-action
      (core/dynamic
       (fn [[outter inner]]
	 (dom/div
	  (dom/p (str "The button has" (if (:pressed? inner) "been pressed" "not been pressed")))
	  buzzer)))
      (fn [ac msg]
	(core/return :state {:pressed? msg})))))
#+end_src
** How state is managed
Like with React, handling state is very important in reacl-c. The framework gives the developer many ways to tackle this problem. Much like with React, developers can easily make out if a component is using or changing state, which makes working with state easier.

State in reacl-c can be shared in different, more complex, ways.
Firstly, while a component might have state, it is not accessible to the developer until they use the ~core/dynamic~ function or ~core/with-local-state-as~ macro. This has the benefit of instantly marking a component as one that needs and works with state.
Secondly, like mentioned earlier, state is split into two categories:
- Inner state, which is defined inside of the component by using either ~core/with-state-as~, ~core/local-state~ or ~core/isolate-state~.
- Outter state, or state that is passed down from the parent component.
The inheritance of state from the parent happens implicitly, but can be controlled by the parent through lenses (with the ~core/focus~ function). These tools are a reason why reacl-c ~items~ are so composable.

While ~core/local-state~ and ~core/isolate-state~ allows us to add additional state to our component, the ~core/dynamic~ function is what gives us access to the state of the component. A combination of either one of the previous two with the ~core/dynamic~ function are often used together. The result has both added state and received access to it. See listing 5 for an example.
#+CAPTION: Using ~core/local-state~ to create an empty string as inner state, which is being changed by the ~onChange~ callback of the input field.
#+begin_src clojure
  (core/defn-item name-input [placeholder]
    (core/local-state
     ""
     (core/dynamic
      (dom/input
       {:placeholder placeholder
	:value inner
	:onChange (fn [[outter inner] e] (core/return :state [outter (.. e -target -value)]))}))))
#+end_src
To change state the ~core/return~ function is used. This time with the ~:state~ keyword, instead of ~:action~. The given payload will be the new state of the component.
* What is a monad
Monads are often described as the programmable semicolon, because they allow us to describe what happens once an operation, that uses a monad, is done. This is helpful, because we can abstract away difficult logic, so that the developer can continue working with our complex types, as if they are primitive types.
There are different kinds of Monads that serve different purposes. One use case for some monads is to allow us to chain operations on often abstracted away types. This is done to transform data or control the flow of the program or both.
In order to allow for sequential composition we need to make use of both, with a heavy focus on controlling when and what is executed and shown.
** The Maybe Monad
A popular monad is the ~Maybe~ type in Haskell. The language doesn't feature a ~null~ value, instead we can use ~Maybe~ to express when a function might return ~Nothing~ or ~Just~ of something. Because this type is a monad we can easily chain it together. This allows us to combine multiple operations that might fail and stop execution in case any of them do[3]. See listing 6 for an example.
#+CAPTION: Instead of having to manually check if each operation succeeded, thanks to the ~Maybe~ type and ~>>=~ operator, the chain will stop if any of the calls return a ~Nothing~.
#+begin_src haskell
  getUserById "df743aec" >>= getTeamByUser >>= getTeamManagerByTeam >>= getSalaryById
#+end_src

Monads are everywhere and most developers will have used them, even if they didn't know what a monad is. They help us write cleaner code that is easier to share and make API's easier to use, because they're composable.
Common cases for monads are IO operations, handling of errors, UI work and to establish a context of values.
** Whats required to be a monad
To be a monad the type needs to provide two functions and satisfy three rules[4]. The required functions are ~>>=~ (also called ~bind~) and the ~return~ function.
A ~bind~ takes an instance of a monad ~M~ and a function that gets a value ~a~ and returns an instance of type ~M~ with ~a~ inside of it. The result will be a monad ~M~ again. This is what enables us to chain these operations together.
The second function, the ~return~, takes a value ~a~ and returns a monad ~M~ with value ~a~. As an example ~Just 1~ works like a return, in that we give it a ~1~ and it gives us a ~Maybe~ (with the value of ~1~ inside of it). The ~return~ function is sometimes also referred to as ~pure~. To better understand the signature, see listing 7 where Haskell notation has been used to spell out the types.
#+CAPTION: Haskell notation of the functions ~bind~ and ~return~
#+begin_src haskell
  M a >>= (a -> M b) = M b
  return a = M a
#+end_src

An implementation of these functions needs to fulfill the following three rules to be considered a monad[5]:
- Left identity: ~return a >>= h = h a~
- Right identity: ~m >>= return = m~
- Associativity: ~(m >>= g) >>= h = m >>= (\x -> g x >>= h)~

Left and right identity are tests to make sure the types work out correctly. ~return~ can both be called with a value to create a monad, when provided on the left side of the bind, or be given as a ~continuation~ function, if provided on the right side. The rule of associativity tests that the order of operation is not important. Both ~(A >>= B) >>= C~ and ~A >>= (B >>= C)~ should yield the same result.
* Current State
Composition is supported in both reacl-c and other frontend frameworks like Angular or React. However, this is limited to creating a new component that just displays all composed components at the same time. In other words, it is only possible to compose in parallel. To create a component which initially displays some component and later changes to display another component, after a certain event has been reached (composing sequentially), the logic doing the change from one to the other component, needs to be implemented by hand. In the following we're going to examine some possible ways to implement a sequence of steps.
** If statement
While not offering composability, a simple ~if~ statement is highly effective for binary choices when it comes to displaying components. An example would be to guard business logic like a dashboard against not logged in users. The ~if~ checks if the user is logged in. If they aren't, the login page (instead of the dashboard) is shown. Otherwise the actual component is displayed.
#+CAPTION: Example of a minimal setup for a guard statement.
#+begin_src javascript
  const app = (isLoggedIn) => {
      return (isLoggedIn)
	  ? <login/>
	  : <dashboard/>
  }
#+end_src
** Switch statement
If we want to have more than a binary choice however, we need to use a switch statement. We can use a switch statement in combination with a variable to keep track of state. Once a certain event (like a click on a button) has occurred, the inner component changes the state to allow for the next component to be rendered.
#+CAPTION: Possible implementation for a component that shows multiple steps, using a switch statement in combination with state, that is changed by a callback which is passed to the individual steps.
#+begin_src javascript
  const login = () => {
      const [step, setStep] = useState(0);
      const [value, setValue] = useState();

      const cb = x => {setStep(step+1); setValue(x)};

      return switch(step) {
	  case 0:
	  return (<personalInfo value={value} cb={cb}/>) ;
	  case 1:
	  return (<verificationCode value={value} cb={cb}/>) ;
	  case 2:
	  return (<showAccountInfo value={value}/>) ;
      }
  }
#+end_src
A simple implementation of a component which shows multiple components in succession can be seen in listing 9. ~personalInfo~, ~verificationCode~, ~showAccountInfo~ are components that will be shown one after another. The ~step~ variable stores which component should currently be shown. The ~value~ variable stores the result of the last step. In order to progress, a callback named ~cb~ needs to be passed to each component, as the point at which the child components are finished can't be determined from the outside (in React). The steps are arranged in sequential order, but in this implementation it is also possible to move non-linearly or even revisit components multiple times. This does mean the callback function would need to map from where which component is being routed. This is examined in detail in listing 10.
Another property to keep in mind is that the components need to be able to at least take a callback function for when they're done. This means components might need to be changed to fit our new logic.
#+CAPTION: Enabling named steps and non-linear visiting of steps by using a second switch case inside of the callback function.
#+begin_src clojure
  (defn login []
    (handle-action
     (dynamic
      (fn [[step val]]
	(case
	    :personal (personal-info val)
	    :verification (verification-code val)
	    :show (show-account-info val))))
     (fn [[step _] ac]
       (return
	:state
	[(case step
	   :personal :verification
	   :verification (if (nil? ac) :verification :show)
	   :show :show) ac]))))
#+end_src
Listing 10 shows the example from listing 9, but it is written in reacl-c and instead of using an increasing number to keep track of which step the component showing, a keyword is used which could be used to show components in a non-linear order or loop back to the initial component after visiting the final component, as well as showing a component multiple times (with different values each time). This however means a second switch statement is needed, to map the transitions from one component to another.

This causes multiple issues. The most immediate is that it's more difficult to add more components, as two places need to be maintained to do so. It is also easy to lose track of which component will be shown next if a complex order is chosen, as no support is being provided by either the language or the framework. There is also no check if the pattern inside of our callback function is non-exhaustive.
Importantly, this also cannot be further composed! Neither listing 9 nor listing 10 can be wrapped by themselves to further build up a sequence, as the inner component has currently no way to signal to the outter component that the next step is to be displayed.
We solved this problem inside of the inner component by passing a callback down, to call us once the next step should be displayed.

We could preemptively add a callback to our implementation, which could be called once the component is done, in case we'd ever need it in the future. This does make our component sequentially composable, however adds even more code to our component. It also requires that we keep track of our steps at yet another place: The point which determines if the component is done (and the final callback should be called). See listing 11 for more.
#+CAPTION: Enhancing the previous implementation by adding an ~onFinish~ callback to the composition itself. The ~cb~ function has been expanded to work with the new function.
#+begin_src javascript
  const login = (onFinish) => {
      const stepCount = 3;
      const [step, setStep] = useState(0);
      const cb = x => {
	  setValue(x);
	  if (onFinish && step >= stepCount) {
	      onFinish(x)
	  } else {
	      setStep(step+1);
	  }
      };

      return switch(step) {
	  case 0:
	  return (<personalInfo value={value} cb={cb}/>) ;
	  case 1:
	  return (<verificationCode value={value} cb={cb}/>) ;
	  case 2:
	  return (<showAccountInfo value={value}/>) ;
      }
  }
#+end_src
While meeting all functional requirements, the implementation provides poor useability. First, we need to write a lot of boilerplate, because we can't abstract away the switch statement as we need direct knowledge about it for our core functionality. Secondly, we need to be aware and handle edge-cases like not being provided a callback, yet having child components continue to ask for a next step etc. Thirdly, nothing is stopping us from doing parallel work in our sequential composition. This means our sequential composition could be used to also sneak in parallel changes that could lead to unexpected behavior which isn't obvious from outside of the component.
** Callbacks
We have already explored how we can use switch statements to obtain sequential composition. However we had to fall back to using callbacks to implement our logic. It is however also possible to skip the switch statement and just use callbacks. This has the benefit of relieving us of a lot of code and making it easier at a glance to understand what is happening.
Listing 12 shows one possible way to implement a component that allows for sequential composability. Listing 13 shows how a developer can use that implementation to sequentially compose.
#+CAPTION: Definition of a composable component using just callbacks. The ~cb~ callback function will be called once if the user clicks the button. The result of the callback is saved as state and from then on will be shown, instead of the old component.
#+begin_src javascript
  const personalInformation = (cb) => { // callback received as parameter
      const [result, setResult] = useState();

      const [email, setEmail] = useState();
      const [password, setPassword] = useState();

      return (result) // display result if present
	  ? result
	  : (<div>
	     <input onChange={setEmail} value={email}/>
	     <input onChange={setPassword} value={password}/>
	     <button onClick={() => setResult(cb(email))}>Continue</button> //callback called and result saved
	     </div>)
  }
#+end_src

At the core it's not much different than the switch-case. We pass down a callback which will be called once the next step is to be shown. The difference is that the book keeping for the next step isn't centralized at the top, but takes place at each and every step. The components themselves can be composed further by making sure the callback itself takes yet another callback, to continue the chain.

#+CAPTION: Using the implementation of listing 12 to compose our steps like in the switch-case example, by building up a chain of functions and passing it to our initial step.
#+begin_src javascript
  const login = () => {
      // compose our steps
      const cb = (email) => <verificationCode email={email} cb={() => <showAccountInfo/>}/>;
      return <personalInformation cb={cb}>
  }
#+end_src
Thanks to the flexibility of callbacks, we can now fully compose sequentially. However, this implementation has a couple of shortcomings. Firstly, we need to keep track of a lot of callbacks. This leads to code that is unpleasant to read (see listing 12). Secondly, we still need to write a lot of code every time we want a sequentially composable component. There is potential to abstract some of it away, but that requires a lot more abstraction to be viable. Writing a lot of code isn't necessarily bad, but could introduce typos and bugs. It also means we have more code that we might want to test.
Most importantly, we again mix our parallel and sequential composition. We want the logic of both to be seperated, because they do different things. Yet every parallel component now needs to do bookkeeping as well.
Lastly, besides the parameter in the signature, there is no way to distinguish from the outside if this is a sequential or parallel component. Placing a single step of a sequential composition into a parallel composition might not make sense and we'd like to make this not possible on an API level.
** Conclusion
Current methods either don't offer composability or they require a lot of boilerplate to be composable. It is possible to write functions which abstract that boilerplate code away, but that takes time and effort.
Support from modern frameworks could not save developers time but also deliver smooth integration with other features of the framework.
* Desired Behaviour
The goal is to create both an easy to use yet powerful tool to compose sequentially. Lets first look at some required features that our implementation should deliver before we talk about how a developer might interact with it.

Our sequential composition needs to handle the synchronicity of the domain. Only one value is to be shown to the user at a time and that is the current value in our list of ~key:value~ pairs. Execution of pairs further in the list needs to be halted until they're displayed. The same should hold true for HTTP requests which a developer could place in our composition.
It's often the case that a step depends on information provided in the previous step. As such it is important for our composition to allow future pairs to access the values returned by the earlier pairs.
Lastly, individual values in the steps should be fully composable. They should be shareable and have the ability to nest in complex ways.

Unlike parallel composition, there are little examples to go off of. Because of this it makes sense to draw inspiration from other, already well established, functions.
ClojureScript provides something that allows us to define things in a neat way with the ~let~ function[6]. As seen in listing 13, a ~let~ is composed of two parameters. The first parameter is a list of ~key:value~ pairs, where a ~key~ is nothing but a name for a symbol that will be used within the ~let~ and ~value~ is the actual value of that ~key~. The second parameter, also called body, is a function which has access to the previously defined keys. It will be run once all the ~values~ have been computed.
#+CAPTION: Using ~let~ to bind values to the names ~one~, ~two~, ~three~. The body is the last line, which is an operation that returns ~6~.
#+begin_src clojure
  (let [one 1
	two (+ 1 one)
	three (inc (* two one))]
    (+ one two three))
#+end_src

Adopting this style for sequential composition has many benefits. The most obvious is that ClojureScript developers would already be familiar with it. Even reacl-c offers a ~let~ style macro in the from of ~ref-let~[7]. It also satisfies a lot of our requirements, like being able to access prior results and only executing one pair at a time. Listings 14 shows how our earlier sign-up example could look like if we used a ~let~ like style. Note how little code is needed. This example still closely follows ~let~ in that it needs an uneven amount of arguments, in which the last is a function that will be executed (with access to all the previously declared ~keys~) at the end.
#+CAPTION: Earlier sign-up example written in a ~let~ style
#+begin_src clojure
  (runner [personal (personal-info)
	   verification (verification-code personal)]
	  (show-account-info [personal verification]))
#+end_src
A possible alternative to this would be to omit the body function entirely and instead use the element previously placed in the body (~show-account-info~ in our example), as the last element in our ~key:value~ pairs list. While not commonly used like this, ~let~ also allows for this style. This has the benefit of creating a concise and consistent look and feel.
#+CAPTION: Login example in ~let~ style without a body function
#+begin_src clojure
  (runner [personal (personal-info)
	   verification (verification-code personal)
	   info (show-account-info [personal verification])])
#+end_src
The ~runner~ function executes our composition and should be able to be used just like a regular ~item~ when wanted. It should be further composibly in parallel with other ~items~ and actions should be able to be caught from it.
Inside of the ~runner~ we will have steps. Those steps should be composable thanks to another function. For now we can steal terminology from the earlier introduced monads and call this function ~bind~ or ~then~.
These two functions should be the primitives of our implementation.
* Why composibility is important
Composability is already hugely important for software developers. Not only can we compose functions with other functions, but it is also what allows us to build modern UI elements so effortlessly. It even got its own OOP software-design pattern in the form of the "Favor Composition over Inheritance" pattern.

The benefits are plentiful. Arguably the biggest advantage is that it allows us to construct bigger things out of many smaller things. This in turn allows us to break a problem into multiple pieces. Being able to address a single concern at a time, we can not only test each piece on their own but also share components easier. Another big benefit is that we can, if constructed correctly, add to our composition forever. Because code evolves over time, this is an appealing property to have.
Both of these attributes are important for frontend development, as we both want to be able to reuse our components and continue to add to them without worry.
* API Design
This being the introduction of sequential composition into reacl-c, it was important to provide strong primitives. Reacl-c already has excellent tools for parallel composition, so the sequential composition should be closely aligned with them, to be intuitive for developers.
The implementation needs to also hide the heavy lifting done in the background and not cause any unexpected issues that would cause it to become unusable for any scenario. The sequential composition should not interfere with the parallel composition and the borders between the two should be clearly visible. Most importantly, developers should be able to compose sequentially however they like without any limitations.
** Used types
While ClojureScript is a dynamically typed language, it is helpful to create types using Clojures ~records~ to make handling and transforming data easier.
The most fundamental type is an UI element, which reacl-c already supplies in the form of ~Item~. To signal that the next step should be executed the ~Item~ needs to emit something which can be recognized internally. For that purpose the ~Commit~ record exists. If an ~Item~ emits a ~Commit~, the internals will execute the next step.
A developer could just pass an ~Item~ for composition, however, it makes sense to have the developer acknowledge that they're working with more than just a simple ~Item~. After all, the ~Item~ should at some point emit a ~Commit~ to change the currently shown step. So, to be able to use the ~item~ for sequential composition, the developer needs to wrap it in a ~Prog~. This signals that the developer understood that the ~Item~ will eventually emit a ~Commit~.
In short:
- ~Item~: UI element
- ~Commit~: What an ~Item~ emits to signal that the sequence can continue
- ~Prog~: An ~Item~ that will ~Commit~
- ~Bind~: Product of composing a ~Prog~ further. Can be composed with itself further.
Internally, there is also a ~Bind~ type, which is the result of a ~then~ call. This holds both a ~Prog~ and a ~continuation~. The continuation will be called once a ~Commit~ has been captured from the ~Item~ inside of the ~Prog~.
** Functions exposed by the API
To deliver on the promises of frictionless composability without loss of performance, monads are used. Because of that, the API needs to provide the ~return~ and ~then~ (also called ~bind~) functions to be considered a monad. Further, to display a ~Prog~ or ~Bind~ easily, a ~show~ function has been added. The most important function is ~runner~, which executes a ~Prog~ or ~Bind~ inside of it, allowing it to walk through the provided steps.
The primivate functions are ~return~, ~then~ and ~runner~.
*** return
The ~return~ function takes an ~Item~ and turns it into a ~Prog~. This allows to go from a parallel composition (with an ~Item~) to a sequential composition (of a ~Prog~). Once an ~Item~ is a ~Prog~ the result can't be further parallely composed.
*** then
The ~then~ function is what allows us to compose multiple ~Progs~ together. For that it takes both a ~Prog~ and a ~continuation~ function (which should return another ~Prog~). The ~continuation~ will be called later, in the ~runner~ function. ~then~ creates a value of type ~Bind~ by passing the ~Prog~ and ~continuation~ parameters along. To allow for composition, the developer can also pass a ~Bind~ instead of a ~Prog~. The ~Bind~ in that case would be a previously created composition.
The goal of ~then~ is to allow for easy composition, just like ~div~ from the ~dom~ namespace of reacl-c. Further composing of a ~Prog~ into another ~Prog~ can be done again with the ~then~ function. It is important that the order of execution will be preserved, no matter the depth of composition.
*** runner
A ~Bind~ cannot be placed directly into a reacl-c ~Item~. To do so, either ~show~ or ~runner~ need to be used to translate the sequential composition back into a parallel composition. While ~show~ just displays the ~Item~ inside, the ~runner~ function acts as a window into the sequential execution, as it captures emitted ~commits~ and cycles through the given steps.
It takes a single ~Bind~ (or ~Prog~) as an argument, which could contain further ~Binds~ inside of it. Once a ~commit~ is emitted from the ~Bind~ that it displays, it calls the ~continuation~ of the ~Bind~ and displays the result of that ~continuation~. If the result is another ~Bind~, emitting another ~commit~ will trigger a call to the ~continuation~ of the new ~Bind~, which should produce yet another ~Bind~ etc.
*** show
~show~ extracts the ~Item~ from the passed parameter, allowing it to be displayed. If it's a ~Prog~ it just takes the ~Item~ inside of the ~Prog~ and displays it. If it is a ~Bind~, it first takes the ~Prog~ inside, then shows the ~Item~. If an ~Item~ is passed, the same ~Item~ will be returned. Show serves as one of two ways to turn a sequential composition back into a parallel one. This however does not capture any emitted ~commits~. If the execution of sequential composition is desired, ~runner~ should be used instead.
** Making the API more intuitive with macros
Earlier we discussed a possible implementation for our sequential composition, using ClojureScripts ~let~ as an inspiration.
We choose that function, among other things, because it's ~key:value~ structure is well understood and is much easier to read than nested anonymous function calls. However, to achieve our goal we need to make use of a ClojureScript feature called macros.
*** Why are macros used here?
From now on, the previously defined functions like ~then~, ~return~, ~runner~ will be called primitives. While these enable us to compose sequentially, they don't work like ~let~ does. Listing 17 shows the current usage of ~then~.
#+CAPTION: Sequential composition using primitive ~then~ with anonymous function calls.
#+begin_src clojure
  (then first
	(fn [a]
	  (then second
		(fn [b]
		  (then third
			(fn [c]
			  (done [a b c])))))))
#+end_src
The developer needs to create the anonymous functions by hand, everytime. Thankfully, the functionality of binding ~keys~ to ~values~ stays the same, as results of the components, like ~first~, will be bound to the parameter in the ~continuation~ (e.g the symbol ~a~).
Because this is functionaly identical, we can write a macro to translate the code example above into the desired ~let~ like structure.
*** What are macros?
Macros are a powerful feature which lets us rewrite our ClojureScript code before it's being evaluated. We do this by selectively telling the language what to evaluate and what to keep for later evaluation. That allows us to use all of ClojureScripts functions to manipulate the input code. This is made possible partly because ClojureScript is a Lisp, so the code already looks like a Clojure data structure. The language uses this to its advantage to operate on itself. The return value of a macro will be a list of code, that will then be evaluated. Because of this we can use the entire language to transform our code, like we transform data, into something more usable.
Macros can be found all over Clojure and ClojureScript. Functions like ~when~[8] and ~when-not~[9] are actually macros that rewrite themselves to a simple ~if~. Even the much discussed ~let~ function is a macro[10].
*** Syntax
The ability to delay evaluation of just some parts of our code is powerful. ClojureScript gives a couple of new symbols to decide how it should evaluate code. We can use these symbols inside of a ~defmacro~ function, which works similar to ~defn~ and ~def~ with which we define functions and values with.
The following table lists the symbols:
| Symbol | Name           | Function                          |
| '      | Quoting        | Stop execution                    |
| `      | Syntax quoting | Like ' but qualify with namespace |
| ~      | Unquoting      | Start execution                   |
If we quote something with ~\'~ or ~\`~ it will not be evaluated yet[11]. The difference between the two is that ~\`~ qualifies each expression with their full namespace. The ~\~~ symbol turns on evaluation inside of a ~\`~ again[11].
*** What are the uses cases for macros?
Macros provide so much freedom that they enable us to enhance not just our API but also the language itself. If the problem is beyond manipulating data, but rather about manipulating code, macros are a good fit.
They allow a developer to provide their API exactly how they imagine it. That's why we will make use of them in our implementation.
However, while things like binding symbols to values under the hood can be used to make things easier for the developer, it can also cause confusion as developers have no idea where the symbol actually came from and can only assume that it works because a macro is used. That assumption gives them little information though. They can also lead to confusing error messages, as another step is added before the evaluation. And because of their freedom they can be complicated to implement. Lastly, as we're going to discuss later, macros aren't as easy to implement in ClojureScript as they are in Clojure. So macros must be used with care, even if they can be a tremendous help.
*** Which macros will be implemented?
Because the structure of ~let~ acts as a dead-end, so too would our ~let~ like structure act as an end for our sequential composition. As such, a macro will be implemented that wraps the ~runner~ primitive and enhances it with the ~let~ like structure. Other macros might be added for easier implementation as well, but are not necessary.
** How parallel and sequential composition interact
The developer should be able to use the API like they use the other tools of reacl-c. At the same time though, there needs to be a clear border between the parallel and sequential composition, as they're fundamentally different. To guarentee that, the API introduced the ~Prog~ and ~Bind~ types. While neither works with the other reacl-c tooling (to discourage incorrect usage), both contain an ~Item~.
Taking a ~Prog~ (or ~Bind~) and turning it into an ~Item~ is simple, thanks to ~runner~ and ~show~. Turning an ~Item~ into a ~Prog~ is also simple and can be done with ~return~,
Functionality that could check if an ~Item~ will ever emit a ~commit~ (or other types), would be something to add in the future. Perhaps an additional keyword like ~:state:~ for the ~return~ function of the ~core~ namespace in reacl-c could be added to handle this case.
It's worth mentioning that that at the borders further composition of the type that has been moved away from, isn't possible anymore. A ~runner~ returns an ~Item~ which from that point on can only be meaningfully parallely composed. Likewise, wrapping a ~Prog~ within a ~div~ with other ~Items~ is also meaningless. The developer needs to make a choice at those points if they really are done composing, in order to switch to the different type.
** What is the result of the last continutation?
There are multiple options for what this behavior could look like. The most obvious answer to the question of what a ~runner~ will return at the end, is that it will show the last ~Prog~ indefinitely. It could also stop displaying anything, though there is little benefit to that.
A more interesting implementation would be to let the developer return whatever they like in the last continuation of the last ~Bind~. So instead of unwrapping a ~Prog~ into an ~Item~ to use with other ~reacl-c~ functions, the ~runner~ could return a normal value at the end. This has the benefit of making our ~runner~ be more than just a display, which will turn in to a dead end. A possible use-case would be the chaining together of HTTP requests where only the result is important to the application.
However usability would suffer, as the developer would need to check if the received value from a ~runner~ is an ~Item~, which should be displayed, or a value, which is to be used for further transformative purposes.
An extension of this idea would be to allow the developer to pass in a body as the last parameter, much like when ~let~ is used. If a body function is provided, the function is given access to all of the intermediate results of the ~Progs~ in the ~runner~ and the result of the body function is returned. If no body is provided, no result will be returned, the last ~Prog~ will just be displayed indefinitely. Like with the previous implementation, this would also suffer from needing to pattern-match the returned value.
*** Reacl-c gives us more options
In many frontend frameworks these options would be all that is possible, but because ~reacl-c~ allows us to emit actions which propagate up the item tree, we can do more than to just display the result on the screen or have the data be returned from the ~runner~ in it's raw form. Thanks to this, the result of the last continuation could be emitted as an action and be caught by a ~handle-action~ function which wraps the ~runner~. This is not perfect either however. One might think that this would mean the pattern-matching might be optional, but it is not. In ~reacl-c~ an action must be caught by something. If it is not and the action reaches the top level item, an error is thrown. By allowing the result to be emitted it is possible to accidentally send an action upwards, by returning something in the last continuation from within a ~runner~. This would result in every single ~runner~ needing to be wrapped by an additional ~handle-action~. One could argue that using ~handle-action~ to catch the returned value, instead of using a function around the ~runner~, like ~cond~, is more idiomatic, as the developers are already using ~handle-action~ to catch actions in the entire ~reacl-c~ app.
This implementation again could be extended by allowing for the last parameter to be a body function, like with ~let~. If the body function is present, the developer can be sure that the ~runner~ needs to be wrapped by a ~handle-action~. If the ~runner~ is only made up of ~Progs~, the developer does not need to do anything. This makes it possible to clearly express when something needs to be caught, but is open for improvement as it requires additional knowledge about how the ~runner~ works. But what would that body function look like? It seems more intuitive to just react to the result in the body function, instead of additionally wrapping the ~runner~ with a ~handle-action~. This implementation also has the problem of not being able to warn the developer that they didn't wrap their ~runner~ with a ~handle-action~.
It does make sense to provide a ~handle-runner~ function which combines this functionality, by taking a ~Bind~ and a function that will handle actions. Actions inside of the ~runner~ won't be returned, but emitted. However, this might be too close to the other implementation and, as an additional function, cause confusion.
*** Potential Use-Cases
The mentioned options all come with downsides. It is important to look at the use-case of the ~runner~, to determine which is suited best for use.
The most obvious use-case is regulating the flow of an entire app. From login, to a dashboard and further. Here what is returned doesn't really matter, as the individual results of the steps that the sequence produces are more important than its final result.
If we look at creating a sequence for a singular workflow, like adding an item to an ecommerce store, the result might be important. It is likely that we want to let the app know that something happened (e.g product added, refresh items), which could also be solved by giving access to the result. Just returning or emitting the last result might be too intrusive (as it forces developers to always wrap ~runner~), but the option to supply a continuation as a "body" could work well here, as it allows the developer to react to the result of the last step.
Another use-cases is the conditional loading of data (from a server). Here the result does matter and we need to provide the possibility to react to it. Of-course, the developer could just add another continuation which reacts to it, but that is rather a hack. The ability to supply a continuation as the "body" would be a great fit, too.
*** Determining the best fit
Seeing how all three of our use-cases benefit from having the option to react to the result, the implementation that just displays the last ~Prog~ indefinitely or shows nothing - is of little use. Using the actions of ~reacl-c~ is nice, but causes unwanted complications. Giving developers the option to handle the result or ignore it, by passing a continuation as a body, allows for all use-cases to work and causes minimal overhead for the developer. This also mirrors the functionality of ~let~.
This however raises the question what should happen if no continuation is supplied. Should the last Prog be shown indefinitely? From a user experience perspective it's expected that an action has a reaction, thus it makes sense to not show something indefinitely, but rather display nothing. Another benefit would be that sequential composition is cleaning it self up, after being done.
** Why monads are a good fit
Using monads makes sense because they allow us to abstract the actual logic (e.g. waiting for a ~Commit~, combining ~Progs~) away from the developer while providing strong tools to combine our sequential steps.
The required functions also are a great fit for our API. With the ~>>=~ operation we give the developer an easy way to further compose their sequential components. ~return~ requires us to make a new type, which we can in turn use to distinguish our sequential and parallel compositions from each other.
Because we wait for a ~Commit~ to be emitted, we need to take asynchronicity into account. Thus we need the previously described tools to build up a blueprint and a specially labeled environment in which that blueprint is being executed in. This is much like monads in Haskell too, where monads can be executed in a ~do~ block.
** Tail Call Optimisation
Neither Java[12] nor versions of JavaScript that we use in our browsers[13], feature Tail Call Optimization (TCO). Both langauges are used as host languages, Java for Clojure and JavaScript for ClojureScript. Due to the high amount of nested function calls it is however an important feature for a functional language. With a correct implementation of Tail Call Optimisation it is guaranteed that successive invocations of nested function calls (like our monadic bind) won't cause a stack overflow. It can also enable the use of recursion with our bind elements. Something that can enable infinitely repeating workflows. Burdening the developer to worry about depth of composition would be undesirable, as the goal is to create an easy to use API.
It is therefore important to add further abstraction to the bind logic, to allow us to implement some kind of TCO around it.
*** TCO in ClojureScript
While ClojureScript isn't offering TCO out-of-the-box for every function call, it does provide the ~loop~ and ~recur~ functions which do a locale rewrite of the code into a loop[14]. This allows for worry free function invocations, no matter the depth.

Another way to gain TCO is to use what is called a trampoline. Instead of stepping deeper and deeper into nested function calls, the function is called once and the result, which is a function, is saved. Now for as long as the function returns another function, we will call the result. If a value is returned, we will stop and return that instead, breaking our ~loop~. Listing 18 shows a crude example. See [12] for a more detailed explanation.
#+CAPTION: Example of trampolines in JS. ~optimized~ calls ~work~ initially and loops for as long as it returns a ~function~.
#+begin_src javascript
  function work(y) {
      return (y === 0) ? true : () => work(y-1);
  }

  function optimized(x) {
      let r = work(x);
      while (typeof r === 'function') r = r();
      return r;
  }
#+end_src
*** Custom TCO
While ~loop~ provides a perfectly fine way to get the benefits of TCO for synchronizing functions, in order to work with the asynchronous, action driven, approach that reacl-c uses, a custom implementation needs to be developed. We will revisit the concept of the trampoline again during our implementation.
* Implementation
Previously we have discussed which functions our API should offer. Now we will focus on implementing these functions and their associated features. Aside from delivering the necessary functionality, we will also talk about optimizing the ~runner~ function and implementing macros for ease of use.
** then
Discussed earlier, the ~then~ function needs to compose steps together. The basic idea is trivial. Take a ~Prog~ and a ~continuation~ and return a ~Bind~, which is nothing but a container ~record~ type that holds both of these values. Listing 18 shows the definition of a ~record~ type as well as the ~make-bind~ function.
#+CAPTION: Record definition of the ~bind~ type and a helper function to filter out incorrect values.
#+begin_src clojure
  (defrecord Bind [prog cont])

  (defn make-bind [prog cont]
    {:pre [(prog? prog)]}
    (->Bind prog cont))
#+end_src

However, just getting a ~Prog~ every time would be of little use. A ~Prog~ just contains a single step. Things get interesting if we want to pass a ~Bind~, because we cannot just wrap the ~Bind~ again, as it already contains a ~Prog~.
If that is the case, ~then~ needs to change the order of execution, to prevent undesirable nesting inside of the ~Bind~. We want our ~Prog~ part of the ~Bind~ to always be shallow for optimization and bookkeeping purposes (see Tail Recursion Optimization). Thanks to the earlier mentioned Law Of Associativity for monads, we can use Continuation Passing Style (CPS) Transformations to swiftly change our previous ~continuation~ into something that gets rid of incorrectly nested calls. This is done by taking the ~Prog~ from the passed ~Bind~ and using it again as our new ~Prog~. The new continuation is an anonymous function which constructs another ~Bind~, by calling the ~continuation~ of the passed ~Bind~ with what is passed to the anonymous function (to create a ~Prog~) and using the passed ~continuation~ as the actual ~continuation~ of the second bind. A visual explanation can be seen in figure 4.
#+CAPTION: ~Prog 1~ is lifted from the passed ~Bind~. The new ~continuation~ is a ~Bind~ out of the previous ~continuation~ and the passed ~continuation~.
#+ATTR_LATEX: :width 350px
[[./images/cps-transformation.png]]
This allows us to avoid having to flatten the ~Bind~ anywhere else, which makes showing the ~Item~ inside of the ~Bind~ trivial. It also guarantees that the order of execution will always be correct, thanks to deconstructing the passed ~Bind~ completely.

Now, inside of our ~then~ function we need to handle both cases. For this we differentiate between a ~then~ call where A: a ~Prog~ is passed or B: where a ~Bind~ is passed. If a ~Prog~ is passed, we just wrap the parameters and return a ~Bind~. If however a ~Bind~ is passed, we do our CPS-transformation. See listing 19 for the previously described code.
#+CAPTION: Definition of the ~then~ function. The CPS-transformation can be seen in line 7, as the previous ~Bind~ and new ~Bind~ are first deconstructed and then reconstructed into a new ~Bind~.
#+begin_src clojure -n 1
  (defn then [prog cont]
    {:pre [(or (bind? prog) (prog? prog) (c/item? prog))
	   (fn? cont)]
     :post [(bind? %)]}
    (if (bind? prog)
      (make-bind (bind-item prog) (fn [x] (then ((bind-continuation prog) x) cont)))
      (make-bind (if (c/item? prog) (make-prog prog) prog) cont)))
#+end_src
To give the developer feedback in case they make an error, we add ~:pre~ and ~:post~ annotations, which let ClojureScript know to check the types that come into and out of our function. In this case we say that the ~prog~ can be a ~Prog~ (or it's subtype ~Bind~). The ~cont~ parameter needs to be a function and the result of our operation should always return a ~Bind~.
** TODO runner
The place for our monad to be executed in is the ~runner~. It will receive a ~Prog~ or ~Bind~. The ~runner~ is the most complex function in our API because of all the things it needs to do:
1. Show current step
2. Bookkeeping of state for steps
3. Catch emitted ~Commits~
4. Make sure implicit state is passed to the ~Prog~ (without leaking own state)
5. And optimize function calls to prevent stackoverflow
As such we will show the code in its entirety once in listing 21 and go in depth about individual parts one after another.
#+CAPTION: The entire definition of the ~runner~ function using trampolines, state-management, lenses and actions.
#+begin_src clojure -n 1
  (defn runner [b]
    {:pre [(or (bind? b) (prog? b))]}
    (core/local-state
     b
     (core/dynamic
      (fn [[_ inner]]
	(core/handle-action
	 (core/focus
	  first-lens
	  (show inner))
	 (fn [[outter st] ac]
	   (if (and (commit? ac) (bind? st))
	     (core/return :state [outter ((bind-continuation st) (commit-payload ac))])
	     (core/return :action ac))))))))
#+end_src
*** Basic Functionality
The goal of the ~runner~ is to hold and display what is inside of a ~Bind~ (or ~Prog~). While it does this, it wraps the ~Bind~ and waits for a ~Commit~ which will trigger it to call the ~continuation~ of the ~Bind~.
To understand this better we're going to focus on lines 7-14 of listing 21. First notice the ~core/handle-action~ call. This function takes two parameters. First an ~Item~ to display, second a ~function~ to call once the ~Item~ emits something. The function that will be called can be seen at the bottom on lines 11-14. We don't directly pass an ~Item~ however. We pass a ~focus~ function. This is done to ~core/focus~ the state on a specific part. Namely limiting the implicitly passed state to what is outside of the runner, instead of leaking the bookkeeping state of the runner downwards. This function again takes two parameters. First a lens (function of two arities) and second an ~Item~. We will talk more about the lense in the next chapter.
The second parameter is the ~show~ function defined in our API, which just takes either ~Bind~, ~Prog~ or ~Item~ and unwraps it to an ~Item~ again.
From this point on we can talk about the ~function~ that was passed to the ~handle-action~, which takes up lines 11-14. That function has two parameters again. First is the state of the ~runner~ at the moment at which the action was emitted from the ~Item~. We have access to this, so we can reduce the state with the second parameter, the action which the ~Item~ sent, into a new state. We then return that new state with the ~core/return~ function (using the ~:state~ keyword). This lets the component know that it needs to update its state, therefore render itself again. In the parameter definition of our function (line 11) the state is destructured into the outter state, which was implicitly passed to our ~runner~ and the state of the ~runner~ itself (here named ~st~). In line 12 we have a check to confirm the ~Item~ sent us an action that is a ~Commit~. If it isn't a ~Commit~, the action will propagate further upwards because of the ~core/return~ call in line 14. We also check if our current state holds a ~Bind~, because only if we have a ~Bind~, can we call a ~continuation~. In line 13 we then call the ~continuation~ of our ~Bind~ with the payload of the ~Commit~ and return it as state of our ~runner~.
*** Lens
The previously mentioned lens in line 9 is needed to stop leaking the bookkeeping for our tail call optimization, downards into our ~Item~.
Lenses are a popular mechanism in functional programming to, on one side, restrict the available information, while allowing changes from the restricted side to change the whole, as well.
It does this by providing two functions: Yanker and shover. The yanker grants access to parts of the whole. If parts of that whole are changed, the shover is called to marry that part again with the whole, so the update can trickle upwards again.
Our lens is a "first lense", because it restricts access to anything but the ~first~ element. This is relevant because when state is passed around in reacl-c, it usually comes in the form of a list where the ~first~ element is the outter and the second element is the inner state.
The code for the ~first-lens~ can be found in listing 22.
#+CAPTION: Elements of the list are destructured into ~first~ and ~rest~, where on the yanker side ~rest~ is discarded and on the shover side ~first~ is ignored in favor of ~small~. ~small~ represents the previously passed ~first~, which now has been updated by the restricted side.
#+begin_src clojure
  (defn first-lens
    ([[first & _]]
     first)
    ([[_ & rest] small]
     (vec (cons small rest))))
#+end_src

Because we don't want the internal state introduced by our ~local-state~ call (inside of our ~runner~) to leak, but we do want the state surrounding the ~runner~ to be passed down, we ignore the inner state (bookkeeping) and pass down the outer state (implicitly passed state).
Our lens is a function with multiple arities. That means it can take different amounts of parameters. Ours being of arity 1 and 2, means it has two different signatures. A signature where it gets one parameter and a signature where it takes two parameters.
To restrict access, so when it is called from the perspective of the child, the signature with one parameter is called. That is our yanker. Here the passed parameter is destructured and everything besides the ~first~ element is ignored. That ~first~ element is then returned. On changes to the state from within our child, the signature with two parameters is called. That is our shover. The change being the second parameter, here called ~small~. We again destructure the argument but now ignore the previously named ~first~ and instead access the previously ignored ~rest~. All that is left to do is to combine them with ~cons~ and return them as a list.
*** Implementing Tail Call Optimization
Previously we discussed what TCO is and why we need it. Now it is time to take a deeper look at how we implement it by examining lines 3-6 and lines 11-14 in listing 21.
As mentioned earlier ClojureScript already provides TCO for functions with the ~loop~ and ~recur~ macros. We however need recursion on our ~Progs~, because of that we cannot simply use ~loop~ and ~recur~. This is not a problem though, as we can use the previously explained concept of trampolines to make our own TCO.
The basic idea is to save the ~Bind~ in our state and update the state each time a ~Commit~ comes in, with the result of the ~continuation~ of our ~Bind~. Updating the state will trigger another render, where the current state is the next step.
Lets examine it in more detail:
In our ~runner~ we define the ~Bind~ that was passed into the function (named just ~b~) as local state using the ~core/local-state~ function. This is the first part of our trampoline. Next we call ~core/dynamic~, which takes a function that has one parameter. That parameter will be the state of our component, which is why we destructure it in line 6 to ~outter~ (which is immediately discarded with ~\_~) and ~inner~ (which is not discarded). This is clever, as we now have access to the state of our ~runner~ component, through the parameter of the function. We need to access that state, because we want to both display the ~Bind~ that it holds and wait for it to ~emit~ a ~Commit~ (using the ~handle-action~ function).
Now, in line 11, we define the function that will be called once an action is emitted. Like mentioned earlier, if the action is a ~Commit~, we execute the code in line 13. Here we set our state to the result of the ~continuation~ of the ~Bind~ of our ~inner~ state, by calling ~core/return~ with the ~:state~ keyword. With that we complete our trampoline. Because we set our state, the component will be rendered again, this time with the updated state, which is the next step in our sequential composition, because it is the result of the ~continuation~ of our ~Bind~.
** show
To display our sequential composition we can use the ~runner~. If however we just want to display one step (indefinitely), we can use ~show~. This is a simple helper function that is used inside of the ~runner~ to display the ~Bind~. At its core it has a ~cond~ call, which allows us to react to specific conditions. This is necessary, because if we get an ~Item~, we can just display it. If however we get a ~Prog~, we need to unwrap the ~Item~ from it. Furthermore, if we get a ~Bind~, we first need to get the ~Prog~ inside of it, before we can unwrap it. Lastly, to make usage easier, if anything else is passed, we display an empty ~fragment~, which is equivalent to nothing. Getting passed neither ~Prog~ or ~Bind~ is the case after finishing the last ~Bind~. See listing 23 for the entire code of the ~show~ function.
#+CAPTION: Code for the ~show~ function.
#+begin_src clojure
  (defn show
    [x]
    {:post [(c/item? %)]}
    (cond
      (prog? x) (prog-item x)
      (bind? x) (prog-item (bind-item x))
      (c/item? x) x
      :else (c/fragment)))
#+end_src
** Macros
The available primitives already enable the developer to craft elaborate sequential compositions, however they aren't able to provide the ~let~ like usage on their own. For this reason, we will implement macros for our API. Only a macro version of the ~runner~ is required, but it makes more sense to enhance the ~then~ primitive first and later wrap the ~runner~ with something that takes advantage of the ~then~ macro. Before we dive into the macros themselves, we first need to take a look at how macros work in ClojureScript.
*** TODO Setup
Both Clojure and ClojureScript have access to macros, though implementing one is more complex in the later. This is because macros are always expanded by Clojure, even if they may produce ClojureScript code. This means Clojure is always involved, even in pure ClojureScript projects. This means the compilation process needs to be kept in mind when writing ClojureScript macros. You cannot, for instance, put macros in a ~.cljs~ file.
Regardless, it is still possible to both write macros for ClojureScript and write macros that use ClojureScript code.
There are multiple ways to write a macro for use in ClojureScript. The easiest would be to write the necessary code in a ~.clj~ (instead of a ~.cljs~) file and importing the macro by pointing the ~:require-macros~ keyword in the namespace definition, to the namespace defined in the ~.clj~ file.
#+CAPTION: Example definition of a macro in ~macros.clj~ that accesses ClojureScript code.
#+begin_src clojure
  (ns code.macros)
  (defmacro example-macro [x] (code.other/function x)) ;; dummy macro
#+end_src
#+CAPTION: ClojureScript file ~other.cljs~ that imports the previously in ~macros.clj~ defined macro with the ~:require-macros~ keyword
#+begin_src clojure
  (ns code.other
    (:require-macros [code.macros :as m]))
  (defn function [x] x) ;; dummy function
  (m/example-macro "example")
#+end_src
Listing 24 shows the definition of a macro in a ~.clj~ file, whereas listing 25 shows the consumption of that macro in a ~.cljs~ file. They also show how a macro can be defined in Clojure, that needs to access ClojureScript code. The important addition is that the source of the macro needs to specify the function with its entire namespace (here ~code.other/function~). Namespaces that want to use the macro need to also require the namespace specified in the macro itself (in our case the ~code.other~ namespace). It is advised to create another namespace that abstracts this work away by providing both the needed namespaces and the macros.
*** then
The goal of our macro is to rewrite the passing of multiple ~Progs~ into a series of ~then~ calls, which then bind the result of each step to a symbol. Like with Clojures ~let~, we want to pass a list of ~key:value~ pairs to our macro. Internally the macro will change this to functional ClojureScript code.
#+CAPTION: The macro will take care of wrapping ~Progs~ in a ~then~ and creates an anonymous functions each time (while binding ~keys~ to function parameters)
#+begin_src clojure
  ;; Before macro
  (runner (then prog1
		(fn [x]
		  (then prog2
			(fn [y] prog3)))))

  ;; After macro
  (runner [x prog1
	   y prog2
	   _ prog3])
#+end_src
Listing 26 hints at what needs to be done. The strategy will be to generate the anonymous functions and to use the supplied ~keys~ (in our case ~x~ and ~y~) as the parameters of our newly generated anonymous functions. This is possible because we need to supply a ~continuation~ to our ~then~ function anyways. That ~continuation~ can have any amount of parameters, but for this to work we only need to give one. Listing 27 shows the macro in its entirety. The core idea of the implementation is heavily influenced from Konrad Hinsen's blog post "Monads in Clojure"[15].

#+CAPTION: The entire macro that wraps our ~Progs~ with ~then~ and generates the anonymous functions.
#+begin_src clojure -n 1
  (defmacro then
    [[var val & rest :as steps] end-expr]
    {:pre [(even? (count steps))]}
    (if steps
      `(code.bind/then ~val (fn [~var] (then ~rest ~(seq end-expr))))
      end-expr))
#+end_src

Our macro takes two arguments. A list of values and an end expression, just like ~let~ does. The list of values is then destructured into three parts. ~var~, ~val~ and ~rest~. The ~var~ will be our symbol, ~val~ the value our ~var~ will be associated too and ~rest~ is what is left of our list.
After making sure that our list is balanced, meaning it has just as many ~vars~ as ~vals~, we check if we have ~steps~ left. ~Steps~ is just a reference to our ~var~ and ~val~, as well as ~rest~. If that is the case, we stop execution of our code with the ~\`~ symbol and begin to build the macro part of our function. We want to call the primitive ~then~ from our ~bind~ namespace, like mentioned earlier, to do this we need to spell out the entire namespace, as we're currently in a ~.clj~ file and cannot import the ~.cljs~ namespace.
Our primitive ~then~ takes two parameters. First a ~Prog~ and second a ~continuation~ function. We use the ~\~~ symbol to undo the syntax quote and pass the ~val~ as is. Then we continue and build our anonymous function. For our macro to work just like ~let~ we need to pass our ~var~, which stands for our symbol (e.g. ~x~ and ~y~ ), as the parameter of our anonymous function. We again undo the syntax quoting using ~\~~, so our actual value is being placed.
Inside of our function we then do a recursive call to our macro, once again undoing the syntax quoting to pass the ~rest~ value of our list and our ~end-expr~ (which is wrapped by a list, to stop it from being executed by ClojureScript). Our ~end-expr~ will be executed once we've worked through all ~steps~. Important to remember is that ~end-expr~ itself might try to access the symbols given in to our ~then~. This now works, because ~end-expr~ is at the bottom of all of our anonymous functions, which provide the context in which these symbols are bound to values. That is because we have actually haven't executed the code, but transformed it by using syntax quoting.
See listing 28 to see how the nesting of anonymous functions works out, to allow ~end-expr~ to have access to the symbols at the end.
#+CAPTION: Example of where ~end-expr~ will be executed.
#+begin_src clojure
  (then prog1
	(fn [x]
	  (then prog2
		(fn [y]
		  (then prog3
			;; assuming end-expr accesses x y z symbols
			(fn [z] (end-expr)))))))
#+end_src
Now our ~then~ macro can be called exactly like we would with ~let~, simply by doing the following:  ~(then [a prog1 b prog2] (fn [] (+ a b)))~ we are able to chain together ~prog1~ and ~prog2~. What we get back is a ~Bind~ of both ~Progs~.
*** runner
With our ~then~ we have greatly improved the desired developer experience, however, the result still returns a ~Bind~. That is fine, as we might want to further compose this. However, we still need to wrap our ~then~ expression with a ~runner~ to run it. To further simplify the experience we will create another macro, this time for the ~runner~ function to give developers the option to do everything within a single call.
For this we will simply wrap our ~then~ macro with our primitive ~runner~ from the ~bind~ namespace. Again we syntax quote our call and undo the quote for our values. To add even more convenience our ~runner~ macro has an arity of two. If the developer is not interested in supplying an ~end-expr~ function, we will pass an empty function into the ~then~ for them. The resulting code is simple but works exactly as we want it to and can be seen in listing 29.
#+CAPTION: Definition of the ~runner~ macro.
#+begin_src clojure
  (defmacro runner
    ([x]
     `(runner ~x (fn [])))
    ([x y]
     `(code.bind/runner (then ~x  ~y))))
#+end_src
** Limitations
While the current implementation achieves what it set out to do, some compromises had to be made. First, as mentioned earlier, it is being relied on the fact that the developer actually emits a ~Commit~ in what they label a ~Prog~. There is currently no logic to make sure that the developer is forced too or reminded if they aren't. Another limitation is that the current API offers only primitives and our two macros, but none of the deep functionality which is found in reacl-c for the parallel composability. So functions that map, filter etc. over sequential compositions are not included. There is also no error handling for sequential composition. Developers need to handle errors by hand in the continuation of the next ~Bind~, as there is no ~Error~ sub-type of ~Commit~. Lastly, there is no way to terminate early, like with a ~Maybe~ monad.
* Examples
With our API now defined and implemented we can take a quick look at some examples, to find out if we have improved the developer experience.
** Sign-up component
Our initial example, to explain what sequential composition is, was a sign-up component. That makes sense because modern sign-up processes are often split up into parts. Lets build that three step sign-up process again, this time with our API.
#+CAPTION: Example usage of our API for the sign-up process shown in the "Motivation" chapter
#+begin_src clojure
  (runner [personal (return personal-info)
	   code (return verification-code)
	   _ (done [personal code])])
#+end_src
Listing 30 shows the sequential composition. We wrap the components inside of ~return~ before passing them but aside from that it looks  identical to a ~let~ call. If the developer knows that the item will only be used in a sequential composition they can of course also use ~def~ and wrap their ~Item~ inside with a ~return~.
The only necessary change inside of our components is to emit a ~Commit~. See listing 31 for this, where we change the behavior of the ~personal-info~ component.
#+CAPTION: Excerpt of the ~personal-info~ component. Parts have been removed for clarity's sake. This is a parallel composition that emits a ~Commit~ once the user presses the button.
#+begin_src clojure
  (core/def-item personal-info
    (core/local-state
     {:name "" :email ""}
     (core/dynamic
      (fn [[outter inner]]
	;; input field code ...
	(dom/button
	 {:onclick (fn [state action] (core/return :action (bind/make-commit inner)))}
	 "Continue")))))
#+end_src
This is all that is needed to create our sign-up process. The ~runner~ can now be placed into a parallel composition.
** Endless loop
Because our ~then~ takes a ~continuation~ for its next step, it's trivial to create an infinite loop. Our macros make this even easier, by abstracting boilerplate code away from us. And because our ~runner~ implemented TCO, we can be sure that our stack won't blow, no matter how often we have looped. Listing 32 shows an example of an infinite loop using our macros.
#+CAPTION: Example of an infinite loop using macros.
#+begin_src clojure
  (defn infinite-loop [n]
    (m/runner [a (item n) ;; helper function which creates Prog
	       _ (infinite-loop (inc a))]))
#+end_src
It could be possible that there is an even compactor way, however this implementation is small enough for now. Worth of note is that the recursive call still receives an integer from the previous step. Also, because this loop never ends, the developer can use ~\_~ to ignore its result, like they would also do with a function parameter.
** Re-using compositions
Using just the ~then~ macro (without the ~runner~), we can save a sequential composition to use it again in multiple places. Because ~runner~ does nothing but call ~then~ under the hood, which in turn takes ~Progs~, we can further compose inside of our ~runner~. See listing 33 for an example of an order process, in which the selection of the product is defined outside of the ~runner~.
#+CAPTION: Using just ~then~ and ~def~ to define a shareable sequential composition.
#+begin_src clojure
  (def burger-selection
    (m/then [size size-selection
	     condiments condiments-selection
	     extras? extra-selection]
	    (fn [] {:size size :condiments condiments :extras? extras?})))

  (def order-process
    (m/runner [credentials login-user
	       order burger-selection
	       payment payment-options
	       _ (confirm-order [credentials order payment])]))
#+end_src
Note that we loose the ability to easily access the results of the previous sequential composition, which happened in the first ~then~. Therefore we have to use the ~end-expr~ of our then, to gain access to these values again in the following composition.
** Mixing primitives and macros
Because our macros don't add additional logic, we can mix primitives and macros! In listing 34 we use our primitive ~then~ inside of our macro ~runner~. Note how we can still access the previously defined symbols (e.g ~a~, ~b~) inside of our primitives.
#+CAPTION: Showcasing composition by using the primitive ~then~ to first compose a complex structure, before inserting it into our macro ~runner~.
#+begin_src clojure
  (def mix-primitives-macros
    (m/runner [a (item 1)
	       b (b/then (item (inc a))
			 (fn [] (b/then (item (+ a 2))
					(fn [x] (item (inc x))))))
	       c (item (+ a b))]
	      (fn [] (+ c 1))))
#+end_src
** Repeatable workflow
In the previous example we saw the benefit of using recursion in our ~runner~. Let's push this further by going beyond a single step. Some software systems are nothing but an endless loop of the same operations. Ordering processes like vending machines come to mind. These are now trivial to create (and enhance) thanks to our sequential composition.
Let's take a disease testing facility as an example. We're going to model the following steps:
1. Enter personal information of patient
2. Select test type and start test
3. Enter test result
4. Print, showcase or send result to patient
Our sequential composition for this process can be seen in listing 35. Noteworthy would be the option to pass the collected information further along, which could be used to collect statistics (e.g for positive cases etc.) by reducing over the information with each successful flow.
#+CAPTION: Example of a system for a facility that is testing for diseases.
#+begin_src clojure
  (defn test-patient-for-disease []
    (m/runner [personal-info aquire-personal-info
	       test-info enter-test-info
	       result enter-test-result
	       _ (showcase [personal-info test-info result])
	       _ (test-patient-for-disease)]))
#+end_src
* Possible improvements
While it can be argued that our API does what it set out to do, there are various ideas that have been pushed aside, to spend more time improving the core of the API.
During the implementation of the ~runner~ the idea for early termination came up. Similar to something like the ~Maybe~ monad, developers could throw a different type of ~Commit~ to tell the chain to break. Inside of the ~runner~ the developer then would have the option to handle the early termination. Whether this could be done by adding a third parameter or by giving a different kind of ~runner~ is yet to be determined. However, giving developers the ability to break the chain at any time could lead to problems, as much like with ~Progs~ actually firing ~Commits~, we can't communicate to the developer that this ~Prog~ might terminate early. This could be solved by making a dedicated type that only works with a subset of operations, but the amount of work required to properly implement this is unknown and likely high.
But, not just a separate type for terminating early would be of interest. Having the ability to communicate that an error has occurred and then being able to handle that (maybe even in different steps of severity) would be also beneficial. A possible scenario would be a lot of time passing since step 1 and step 2 and the user gets logged out. Instead of having to handle the error either outside of the ~runner~ or inside of every single step, we could dedicate a space inside of the ~runner~ for exactly that.
Besides new types, another improvement would be to force a developer to ~Commit~ something inside of a ~Prog~. The implementation for this is unclear, however the feature is of interest as that could be a major source of bugs.
Lastly, helper functions for sequential composition, like the ones that exist in reacl-c for parallel composition, could be a possible addition. Things like a ~def-prog~ function that works like ~def-item~ but also wraps the resulting ~Item~ inside of a ~return~ or the ability to map actions emitted from a component to be ~Commits~ so the actual component doesn't need to be changed, but can still be used inside of a sequential-composition. There are probably many more applications of the deep pool of functions inside of reacl-c, so these are just some that came to mind.
* Conclusion
Having used our API to build the earlier mentioned examples, it is clear to us that our implementation delivers what it set out to do: Enable sequential composition in a developer friendly way. Creating sequences of steps is now much easier and composable. Despite all of the work happening under the hood, from tail call optimization to handling the asynchronously, the developer can use the API without ever being bothered by either. At the same time usage is simple, thanks to taking an already well understood way of working with data, like ~let~, as an inspiration.
While the API could be enhanced, the added complexity of some proposals could also take away from the currently present simplicity. It's best to first see how the current implementation solves the problems presented by workflows, before making big additions.
We're pleased with the implementation and are excited to find out what we can build with it in the future.
* Sources
- [1] https://reactjs.org/
- [2] https://github.com/active-group/reacl-c/
- [3] https://www.youtube.com/watch?v=YDj20ySKWP8
- [4] https://wiki.haskell.org/Monad
- [5] https://wiki.haskell.org/Monad_laws
- [6] https://clojuredocs.org/clojure.core/let
- [7] https://github.com/active-group/reacl-c/blob/0.10.10/src/reacl_c/core.cljc#L94
- [8] https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L493
- [9] https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L499
- [10] https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L4481
- [11] Quick Clojure: Effective Functional Programming - 10. Macros
- [12] Tail Call Optimization in the Java HotSpotTM VM
- [13] https://2ality.com/2015/06/tail-call-optimization.html
- [14] https://www.learn-clojurescript.com/section-2/lesson-11-looping/
- [15] https://github.com/khinsen/monads-in-clojure


