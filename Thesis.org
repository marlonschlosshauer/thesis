#+TITLE: Composition of UI elements in reacl-c using monads
#+AUTHOR: Marlon Schlosshauer, Applied Computer Science, Hochschule Offenburg
#+LANGUAGE: english
#+OPTIONS: \n:t
#+OPTIONS: toc:nil
#+OPTIONS: broken-links:auto
#+LATEX_HEADER: \hypersetup{colorlinks=true, linkcolor=black}

#+LATEX: \newpage
#+TOC: headlines
#+LATEX: \newpage

* Abstract
* Motivation
Components are an important tool in modern frontend development. In traditional frameworks we can define something as an component to reuse it multiple times in our applications, encapsulate some style with some functionability or collect multiple elements into a single component. To be more precise, we can compose things in parallel. An example of a parallel composition would be two input fields and a button, which together define a sign-in component.

Modern frontend applications have gone beyond just serving information with HTML. They act as a digitalization of a workflow, where the order of components, as in which component is shown after another, is crucial. This is also a kind of composition. Instead of composing things in parallel, we're composing sequentially here. This is to say, we say which steps we have and together they form a sequence.
The resulting sequentiality is different from how we know it from imperative programming, as we don't mutate state with each step, rather the result of each step is fed into the next step. This allows us to adress the essential sequentiality of the domain while not creating accidental sequentiality, because sequentiality isn't our only tool.
An example of a sequential composition would be to first show a sign-in component, then after a successful login show the actual component the user wanted to access.
Composing sequentially isn't just an optimization, it's a fundamental building block of how an application is supposed to operate. Just how we need the ability to show both an input field and a button at the same time (to confirm the input), we also need the ability to model what happens after that button has been pressed.

But despite the need, the actual support for sequential composibility by modern frameworks is either non existent or very poor.
While some of the desired result can be achieved by making clever use of parallel composibility or using traditional links and routing, neither is truly sequentially composible and both suffer from multiple issues, some of which are:
- They don't yield things which we can compose further (into more complicated workflows)
- Reusing these components leads to a lot more abstraction
- It produces code that becomes difficult to understand at a glance
- Most importantly the logic for advancing the steps and the book-keeping lives now inside the component with the parallel composing logic
There are more issues like the inability to easily test just the order of the components and the huge time cost required to refactor constructs of this nature.

Our applications already are a collection of parallel compositions. If we add the ability to compose sequentially, we can use another axis to control our programs and build complicated hierchies, where an application consistst of one sequentially composed component, that inside of it has either more sequentially or parallel composed components.
Not only would our code be more expressive and more concise, bugs could also be reduced because the systems we build can be represented more truthfully by the provided api of the framework. But most importantly we could build workflows out of smaller flows or other workflows entirely and share these across our applications.
Given the lack of support and possible application it is of high interest to find a way to compose sequentially, easier.
* What is React
React is a popular UI framework developed by Facebook and written in JavaScript. Like other modern JavaScript frameworks, it is a Single-Page-Application (SPA), which means the entire application is available and loaded from a single page. Instead of having each page defined in HTML, developers are able to define their pages in JavaScript, using Reacts JavaScript Syntax Extension (JSX). React takes those JSX definitions and builds HTML accordingly, before adding it to the browsers DOM.
#+CAPTION: Example of JSX to define a profile
#+begin_src javascript
  const profile = ({name, age, image}) => {
      return (
	      <div className="profile-container">
	      <div className="profile-info-container">
	      <p>{name}</p>
	      <p>Age: {age}</p>
	      </div>
	      <img alt={`Avatar of ${name}`} src={image}/>
	      </div>
      )
  }
#+end_src

An advantage of a SPA design is that commonly used components, like a header and footer, can be shared over multiple pages without having to be retransmitted, as the JavaScript code is still in memory. In such a system navigation does not change the current page, but rather tells React to build the desired next page from the JSX definition. Besides requiring less bandwith on succesive visits, this also leads to better response times on page visits after the initial load, as those pages are also already in memory.

Another important feature of React is that the developer must explicitly declare the state of a component. This is used to improve performance, as only components which
which are effected by a state change are freshly render. Old components remain untouched in memory.

React is also a popular basis for other frameworks like Preact, Reagent, reacl-c and others.
* What is reacl-c
Reacl-c is a UI framework for ClojureScript that is designed to make the composition of UI components easier. Like other ClojureScript frameworks (Reagent, Om, Rum), reacl-c wraps React to take advantage of Clojures immutable datastructures. Like React, reacl-c allows the defining of components, called "items" in reacl-c. These items can have child items, thus forming a tree, just like in React.

To make composing of items easier, reacl-c takes a different approach to state than React. There are two types of state. Local state, which is defined inside of the component and outter state, which is implicitely passed down from the parent to the child. The later puts the emphasis on the parent.

A key difference to React, is that items can emit actions if an event occurs. These actions propogate upward the item tree. Every item can register an action handler which captures the action and reacts to it. This enables the developer to define a (child) item completely independently from their potential future parents, leading to more reusable and more composible components.
Instead of having the parent pass down a function to, e.g manipulate state, the component can emit an action upwards and trigger the same functionability in the parent. Another benefit is that the parent component can adapt the output of the emitted action further.
As an example: A button toggles an "option" from ~true~ to ~false~ and back. The state for this "option" is put into the parent, as the child will be reused across the application. In React, the button needs to receive a function which to callback, after the button had been pressed. In reacl-c the button does not need to receive anything from the outside world (necessarily, styling and text might be applied), as the button emits an action when pressed, which the parent can capture and act upon.
#+CAPTION: We create an item called ~abstract-button~ which contains a button. If pressed, it's going to fire an ~:action~ with the value ~:pressed~ to it's parent.
#+begin_src clojure
  (defn-item abstract-button [text]
    (dom/button {:onClick (fn [] (core/return :action :pressed))} text))
#+end_src
With this style of communication, only the parent needs to know the child. The developer does not need to tell the child where to send the action. Reacl-c takes care of that work for us.

To make components even more composible the parent can not just control the result, it can also control which state is given to it's children in the first place. The parent can therefor handle the child items like they're pure functions, that together with the parent compose to a new item.

In React often another package like Redux is used to fix the problem of having to passdown functions. Instead of saving all state in each component, state can be managed at a central point which components can send messages to, causing the central state to change. This can cause issues with the composibility of components. The problem with this approach is that components cannot be placed multiple times into the app, without making sure they don't all work on the same central state. Reacl-c solves this issue by allowing any component to send and receive messages. Not only does this allow for local reasoning, but it also enables to wrap a component with an action handler and placing it infinitely in the app without worry, as the component won't effect anything outside of that handler.
** How an Item is made
Reacl-c is made up of so called items and functions which operate on these items. Much like in React they are instructions that represent HTML elements that can be nested and can hold state.
To make an item reacl-c provides a namespace called ~dom~ that contains all the necessary DOM HTML components already defined as items. All that is needed to create a headline is ~(dom/h2 "Headline")~. To make more complicated items, combinators like ~(dom/div)~ or ~(core/fragments)~ can be used. These can contain multiple items.
#+CAPTION: Showcasing composition of multiple items into one by using a div
#+begin_src clojure
  (dom/div
   (dom/h2 "Hello")
   (dom/p {:class "subtitle"} "This is some text")
   (dom/button "Subscribe"))
#+end_src
There are other functions which, much like div, don't add something visually but change the behaviour of the item. Functions like ~core/focus~, ~core/dynamic~ and ~core/handle-actions~, to just name a few.

Items can also receive a map as their first argument. With this map things like CSS classes, inline-style can be provided. If the item is an interactive one like Buttons and inputs (to name a few), the keywords ~onChange~ and ~onChange~ can be used to register a callback.
** Emitting and handling actions
Actions are an important tool for children to communicate with their parents. Like the implicit (or explicit) passing of state from the parent, this is a crucial feature to make items composible.
To emit an action the child needs to call ~core/return~ with the ~:action~ keyword and the desired payload. The action will travel upwards until it's caugh by a ~core/handle-action~. Handle action takes two arguments, first an item to wrap (and receive actions from) and second a function that defines what do to when it received an action.
#+CAPTION: The action emitted by the buzzer item is caught in the parent item
#+begin_src clojure
  (def buzzer
    (dom/dom
     (dom/h3 "Press buzzer to notify parent")
     (dom/button {:onClick (fn [] (c/return :action true))} "Buzzer")))

  (def parent
    (core/local-state
     {:pressed? false}
     (c/handle-action
      (core/dynamic
       (fn [[outter inner]]
	 (dom/div
	  (dom/p (str "The button has" (if (:pressed? inner) "been pressed" "not been pressed")))
	  buzzer)))
      (fn [ac msg]
	(c/return :state {:pressed? msg})))))
#+end_src
It is important that the function which given to ~core/handle-action~ calls ~core/return~ at the end to either notify a parent of itself or change state, as an action is just a side-effect.
** How state is managed
Like with React, handling state is very important in reacl-c. The framework gives the developer many ways to tackle the problem. Thankfully, much like with React, the developer can easily make out if a component is using or changing state.

State in reacl-c can be shared in different, more complex, ways.
Firstly, while a component might have state, it is not accessable to the developer until they use the ~core/dynamic~ function. This has the benefit of instantly marking a component as one that needs and works with state.
Secondly, state is split into two categories:
- Inner state, which is defined inside of the component by using either ~with-state-as~, ~local-state~ or ~isolate-state~.
- Outter state, or state that is passed down from the parent component.
The inheritance of state from the parent happens implicitely, but can be controlled by the parent through lenses (with the ~core/focus~ function). Like mentioned earlier, this part of the reason why reacl-c items are so composible.

While ~with-state-as~ allows us to add additional state to our component, the ~dynamic~ function gives us access to all the state that this component has to offer. These two functions are often used together, to create a component that needs to both have local state and react to it.
#+CAPTION: Using ~local-state~ to create an inner state of an empty string, which is being changed by the ~onChange~ callback of the input.
#+begin_src clojure
  (c/defn-item name-input [placeholder]
    (c/local-state
     ""
     (c/dynamic
      (dom/input
       {:placeholder placeholder
	:value inner
	:onChange (fn [[outter inner] e] (c/return :state [outter (.. e -target -value)]))}))))
#+end_src
To change state the ~core/return~ function is used again. This time with the ~:state~ keyword, instead of ~:action~. The given payload will be the new state of the component.
* What is a monad
There are different kinds of Monads that serve different purposes. They're often described as the programmable semicolon, because they allow us to describe what happens once an operation, that uses a monad, is done. One use case for some monads is to allow us to chain operations on often abstracted away types to transform data or control flow. In order to allow for sequential composition we need to make use of both, with a focus on controlling when what is executed and shown.
A popular monads is the ~Maybe~ type in Haskell. The language doesn't feature a ~null~ value, instead we can use ~Maybe~ to express when a function might be return ~Nothing~ or ~Just~ of something. What makes this type a monad is the fact that we can chain it together. This allows us to combine multiple operations that might fail and stop execution in case it does.
#+CAPTION: Instead of having to manually check if each operation succeded, thanks to the ~Maybe~ type and >>= operator, the chain will stop if one of the calls fails.
#+begin_src haskell
  getUserById "df743aec" >>= getTeamByUser >>= getTeamManagerByTeam >>= getSalaryById
#+end_src

Monads are everywhere around us and most developers will have used them, even if they didn't know what a monad is. They help us write cleaner code that is easier to share.
Common cases for monads are IO operations, handling of errors, UI work and to establish a context of values.
** Whats required to be a monad
To be a monad a type needs to implement two functions and comply with three rules. The required functions are ~>>=~ (also called bind) and ~return~.
A bind takes an instance of a monad ~M~ and takes a function that gets a normal value and returns another instance of that type ~M~. The bind function return the result of the second argument, the passed function. We give it a monad and a function and get another monad out. This is what enables us to chain these operations together.
The second function, the ~return~, takes a value and makes a monad out of it. This usually means wrapping the value in a monad type. As an example ~Just 1~ works like a return, in that we give it a ~1~ and it gives us a ~Maybe~ value (with the value of 1 inside of it). Return is sometimes also referred to as ~pure~.

It's often helpful to see these functions in the Haskell notation, to understand them. See Listing for more.
#+CAPTION: Haskell notation of the functions bind and return
#+begin_src haskell
  M a >>= (a -> M b) = M b
  return a = M a
#+end_src

Our implementation of these functions need to fullfill the following three rules to be considered a monad:
- Left identity: ~return a >>= h = h a~
- Right identity: ~m >>= return = m~
- Associativity: ~(m >>= g) >>= h = m >>= (\x -> g x >>= h)~

Left and right identity are tests to make sure the types work out correctly. ~return~ can both be called with a value to create a monad, when provided on the left side of the bind, or be given as a continuation function, if provided on the right side. The rule of associativity tests that the order of operation is not important. Both ~(A >>= B) >>= C~ and ~A >>= (B >>= C)~ should yield the same result.
* Current State
Composition is supported in both reacl-c and other frontend frameworks like Angular or React etc. However, this is limited to creating a new component that just displays all composed components at the same time. In other words it's only possible to compose in parallel. To create a component which initially display some component and later changes to display another component, after a certain event has been reached (composing sequentially), the logic doing the change from one to the other component, needs to be implemented by hand.
A common way to implement this, is to use a switch statement in combination with a variable to keep track of state. Once a certain event (like a click on a button) has occured, the component changes the state to allow for the next component to be rendered.
#+begin_src javascript
  const login = () => {
      const [step, setStep] = useState(0);
      const [value, setValue] = useState();

      const cb = x => {setStep(step+1); setValue(x)};

      return switch(step) {
	  case 0:
	  return (<personalInfo value={value} cb={cb}/>) ;
	  case 1:
	  return (<verificationCode value={value} cb={cb}/>) ;
	  case 2:
	  return (<showAccountInfo value={value}/>) ;
      }
  }
#+end_src
A simple implementation of a component which shows multiple components succesively can be seen in Listing 1. ~personalInfo~, ~verificationCode~, ~showAccountInfo~ are components that will be shown one after another. The ~step~ variable stores which component should currently be shown. The ~value~ variable stores the result of the last step. In order to progress, a callback named ~cb~ needs to be passed to all components, as the point at which the child components are finished can't be deteremed from outside (in React). The steps are arranged in sequential order, but it is also possible to move non-linearly or even revisit components mutliple times. This does mean the callback function needs to map from where which component is being routed. This will be examined in more detail in Listing 2.
Another property to keep in mind is that the components need to be able to at least take a callback function for when they're done. This means components might need to be changed to fit our new logic.
#+begin_src clojure
  (defn login []
    (handle-action
     (dynamic
      (fn [[step val]]
	(case
	    :personal (personal-info val)
	    :verification (verification-code val)
	    :show (show-account-info val))))
     (fn [[step _] ac]
       (return
	:state
	[(case step
	   :personal :verification
	   :verification (if (nil? ac) :verification :show)
	   :show :show) ac]))))
#+end_src
Listing 2 shows the example from Listing 1, but it's written in reacl-c and instead of using an increasing number to keep track of which step the component is on, a keyword is used which could be used to show components in a non-linear order, loop back to the inital component after visiting the final component or to show a component multiple times (with different values each time). But this means a second switch statement is needed, to map the transitions from one component to another.

This causes multiple issues. The most immidiate is that it's more difficult to add more components, as two places need to be maintained to do so. It is also very easy to lose track of which component will be shown next, if a complex order is choosen, as no support is being provided by either the language nor the framework. Importantly, this also cannot be further composed! We would need to copy the entire logic to another component to wrap our flow of components, with another flow of components. Unlike the other items in reacl-c if this item acts as a child, the parent will not be able to influence the input and output of this item.
* Desired Behaviour
The goal is to create both an easy to use yet powerful tool to compose sequentially. Unlike with parallel composition, there are little examples to go off of. Because of this it's easy to draw inspiration from other, already in use functions.
ClojureScript already provides something that allows us to define things in a neat way, with the ~let~ function. As seen in Listing 3, a ~let~ is composed of two parameters. The first parameter is a list of ~mapping:value~ pairs, where a mapping is nothing but a name to be used within the ~let~ and a value is the actual value of that name. The second parameter, the body, is a function which can use the mappings given in the first parameter, to execute some operation.
#+CAPTION: Using ~let~ to bind values to the names ~one~, ~two~, ~three~
#+begin_src clojure
  (let [one 1
	two (+ 1 one)
	three (inc (* two one))]
    (+ one two three))
#+end_src
Another benefit of adopting this style is that ClojureScript developers would already be familiar with it.

An important feature for our sequantial composition is the need for synchronosity. Only one value is to be shown to the user at a time and that is the current value in our list of ~mapping:value~ pairs. Execution of pairs further in the list is halted until they're reached. The same should hold true for HTTP requests which could be added to the list.
Future pairs should also be able to access the value returned by the earlier pairs, just like how you can access ~one~ while calculating the value of ~two~ in our ~let~ example earlier.
Of-course individual values in the ~mapping:value~ pairs should also be able to be composible with other values, so one step in one flow, can be an entire different, nested, flow.

Listings 5 shows our earlier example implemented with the desired functionality given by the framework. Note how little code is needed. This example still closely follows ~let~ in that it needs an uneven amount of arguments, in which the last is a function that will be executed (with access to all the previously declared names) at the end.
#+CAPTION: Earlier login example written in a ~let~ style
#+begin_src clojure
  (runner [personal (personal-info)
	   verification (verification-code personal)]
	  (show-account-info [personal verification]))
#+end_src
A possible alternative to this would be to omit the body function entirely and instead use the element previously placed in the body (~show-account-info~ in our example), as the last element in our ~mapping:value~ pairs list. While breaking with the ~let~ style, this has the benefit of creating a concise and consistent look and feel.
#+CAPTION: Login example in ~let~ style without a body function
#+begin_src clojure
  (runner [personal (personal-info)
	   verification (verification-code personal)
	   info (show-account-info [personal verification])])
#+end_src
The ~runner~ function executes our composition and should be able to be used just like a regular item when wanted. It should be able to be composed parallel with other items and actions should be able to be caught from it.
* Implementation
Creating an API for sequential composition brings some challenges with it.
Reacl-c already provides excellent tools for parallel composition, so the API for sequential composition should be intiuitive as well. It needs to hide the heavily lifting done in the background and not cause any unexpected issues, that would cause it to become unuseable for some scenarios. The sequential composition should not interfere with the parallel one and the border between the two should be clearly visible.
And most importantly, developers should be able to compose sequentially how ever they like.
** Used types
While ClojureScript is a dynamically typed language, it is helpful to create types using Clojures ~records~, to make handling and transforming data easier.
The most fundermental type is an UI element, which reacl-c already supplies in the form of ~item~. To signal that the next step should be executed, the ~item~ needs to emit something, which can be recognized internally. For that purpose the ~commit~ record exists. If an ~item~ emits a ~commit~, the internals will execute the next step.
A developer could just pass an ~item~ for composition, however, it makes sense to have the developer acknowledge that they're working with more than just a simple ~item~. After all, the ~item~ should at some point emit a  ~commit~ to change the currently shown step. So, to be able to use the item for seq. composition, the developer needs to wrap it in a ~Prog~. This signals that the developer understood that the ~item~ will eventually emit a ~commit~. Perhabs further work  could be here, to guarente that a developer is alerted if their code never emits a ~commit~.
In short:
- Item: UI Element
- Commit: What an Item emits to signal next exection
- Prog: An Item that will Commit
Internally, there is also a ~Bind~ type, which is the result of a ~then~ call. This holds both a ~Prog~ and a continuation, that will be called once a ~commit~ has been captured.
** Functions exposed by the API
To deliver on the promises of frictionless composibility without loss of performance, monads are used. The API needs to provide the ~return~ and ~then~ (also called ~bind~) functions to be considered a monad. Further, to display a ~Prog~ or ~Bind~ easily, a ~show~ function has been added. The most important function is ~runner~, which executes a ~Prog~ or ~Bind~ inside of it, allowing it to walk through it's steps.
*** return
The ~return~ function takes an ~Item~ and turns it into a ~Prog~.
*** then
The ~then~ function is what allows us to compose multiple ~Progs~ together. For that it takes both a ~Prog~ and a continuation function (which should return another ~Prog~). The continuation will be called later, in the ~runner~ function. ~then~ creates a value of type ~bind~ by passing the ~Prog~ and continuation parameters along. To allow for composition, the developer can also pass a ~Bind~ instead of a ~Prog~. The ~bind~ in that case would be a previously created composition. If the case, ~then~ needs to apply CSP transformation to change the order of execution, to prevent undesirable nesting inside of the ~Bind~. We want our ~Prog~ part of the ~Bind~ to always be shallow for optimization and book-keeping purposes. Thanks to the earier mentioned Law Of Associativity for monads, we can use CSP transformations to easily change our previous continuation into something that gets rid of the nested calls. This is done by taking the ~Prog~ from the passed ~Bind~ and using it again as our new ~Prog~. The new continuation is an anonymous function which constructs another ~Bind~, by calling the continuation of the passed ~Bind~ with whats passed to the annoymous function (to create a ~Prog~) and using the passed continuation as the actual continuation of the second bind.
#+CAPTION: ~Prog 1~ is lifted from the passed ~Bind~. The new cont is a ~Bind~ out of the previous cont and the passed cont.
[[./images/csp-transformation.png]]
This allows us to avoid having to flatten the ~Bind~ anywhere else, which makes showing the ~Item~ inside of the ~Bind~ (and ~Prog~) very easy. It also guarentees that the order of execution will always be correct, thanks to deconstructing the passed ~Bind~ completely.
#+CAPTION: Definition of the ~then~ function using csp-transformation
#+begin_src clojure
  (defn then
    [prog cont]
    (if (bind? prog)
      (make-bind (bind-item prog) (fn [x] (then ((bind-continuation prog) x) cont)))
      (make-bind (if (item? prog) (make-prog prog) prog) cont)))
#+end_src
*** show
~show~ extracts the ~Item~ from the passed variable, allowing it to be displayed. If it's a ~Prog~ it just takes the ~Item~ inside of the ~Prog~. If it is a ~Bind~, it first takes the ~Prog~ inside, then shows the ~Item~. If an ~Item~ is passed, the same ~Item~ will be returned.
This however does not capture any emmited ~commits~. If the execution of sequential composition is desired, ~runner~ should be used instead.
*** runner
A ~Bind~ cannot be placed directly into a reacl-c ~Item~. To be done so, either ~show~ or ~runner~ needs to be used, to translate the sequential composition into a parallel composition. While ~show~ just displays the ~Item~ inside, the ~runner~ function acts as a window into sequential execution, as it captures emitted ~commits~ and cycles through the given steps.
It takes a single ~Bind~ as an argument, which could contain further ~Binds~. Once a ~commit~ is emmitted, it calls the continuation of the ~Bind~ and displays the result. If the result is another ~Bind~, emitting another ~commit~ will trigger a call to the continuation of the new ~Bind~, which should produce another ~Bind~ etc.
The ~runner~ itself holds the current ~Bind~ as state (see "Tail Call Optimisation" for why), while wrapping it's ~Item~ with a ~handle-action~ to listen for an emitted ~commit~.
#+CAPTION: Definition of the ~runner~ function using trampolines for tail-call-optimisation
#+begin_src clojure
  (defn runner
    "Show `Prog` (or `Bind`). Returns an `Item`"
    [b]
    {:pre [(or (bind? b) (prog? b))]}
    ;; inner state of book-keeping is the bind
    (c/isolate-state
     b
     (c/dynamic
      (fn [st]
	(c/handle-action
	 ;; display item in bind/prog
	 (cond
	   (bind? st) (show (bind-item st))
	   (prog? st) (show st)
	   :else st)
	 (fn [st ac]
	   ;; call continuation of bind on commit
	   (if (and (commit? ac) (bind? st))
	     (c/return :state ((bind-continuation st) (commit-payload ac))))))))))
#+end_src
** Making the API more intuitive with macros
Earlier we discussed a possible implementation for our sequential composition, using ClojureScripts ~let~ as an inspiration.
** Whats the semantic of the functions?
** How are errors handled?
** Should early termination be possible?
Seeing how the use-case is all about making it possible to compose steps together, should it be possible to premeaturely exit the chain of operation, from within a ~Prog~? It's important to keep in mind that a ~Prog~ could be used from a different part of the application and the developer would have no idea if that ~Prog~ has the possibility to terminate itself (and therefore the chain) early, without looking at the code.
** What is the result of the last continutation?
There are multiple options for what this behaviour could look like. The most obivous answer to the question, of what a ~runner~ will return at the end, is that it will return nothing. The content of the last ~Prog~ will be returned and therefor be shown indefinitely. This certainly works but doesn't realize the full potential of the idea, of using monads to chain flows of ~Progs~ together.
A more interesting implementation would be to let the developer return whatever in the last continuation of the last ~Bind~. So instead of unwrapping a ~Prog~ into an ~Item~ to use with other ~reacl-c~ functions, the ~runner~ could return a normal value at the end. This has the benefit of making out ~runner~ be more, than just a display that will turn in to a dead end. A possible use-case would be the chaining together HTTP requests where only the result is important.
However useability would suffer, as the developer would need to check if the received value from a ~runner~ is an ~Item~, which should be displayed, or a value, which is to be used for further transformitive purposes.
An extension of this idea would be to allow the developer to pass in a body as the last parameter, much like when ~let~ is used. If a body function is provided, the function is given access to all of the intermediate results of the ~Progs~ in the ~runner~ and the result of the body function is returned. If no body is provided, no result will be returned, the last ~Prog~ will just be displayed indefinitely. Like with the previous implementation, this would also suffer from needing to pattern-match the returned value.

In many frontend frameworks these three options would be all that is possible, but because reacl-c allows us to emit actions which propagate up the item tree, we can do more than to just display the result on the screen or have the data be returned from the ~runner~ in it's raw form. Thanks to this, the result of the last continuation could be emitted as an action and be caught by a ~handle-action~ function which wraps the ~runner~. This is not perfect either. One might think that this would mean the pattern-matching might be optional, but it is not. In ~reacl-c~ an action must be caught by something. If it is not and the action reaches the top level item, an error is thrown. By allowing to emit the result it is possible to accidentally send an action upwards, by returning something in the last continuation from within a ~runner~ and to be unaware that this ~runner~ would need to be wrapped by an ~handle-action~ function, because there is no way to warn the developer of this (like with using Exceptions in Java). But, one could argued that using ~handle-action~ to catch the returned value, instead of using a function around the ~runner~, like ~cond~, is more idiomatic, as the developers are already using ~handle-action~ to catch actions in the entire ~reacl-c~ app.
Again this implementation could be extended by allowing for the last parameter to be a body function, like with ~let~. If the body function is present, the developer can be sure that the ~runner~ needs to be wrapped by a ~handle-action~. If the ~runner~ is only made up of ~Progs~, the developer does not need to do anything. This makes it possible to clearly express when something needs to be caught, but is open for improvement as it requires additional knowledge about how ~runner~ works. There is, again, also no way to warn a developer of they have not wrapped a ~runner~ with an ~handle-action~, if they forgot too.

These options all come with downsides. It is important to look at the use-case of the ~runner~ in real applications, to determine which is suited best for use.
Like discussed earlier, the most common use-case will be the orchestrating of multiple steps, that all happen in a rigid order.
** How does the "Item" world and "Prog" world interact?
** Limitations
** Tail Call Optimisation
Neither Java nor JavaScript, the two host languages for Clojure and ClojureScript respectively, feature Tail Call Optimization (TCO). Due to the high amount of nested function calls it is however a very important feature for a functional language. With a correct implementation of Tail Call Optimisation it is guarenteed that successive invocations of a monadic bind won't cause a stack overflow. It can also enable the use of recursion with our bind elements.
It is therefore important to abstract away the bind logic from the developer, to implement some kind of TCO around it.
*** Tail Call Optimisation in ClojureScript
While ClojureScript isn't offering TCO out-of-the-box for every function call, it does provide the ~loop~ and ~recur~ functions which do a locale re-write of the code into a loop.
Another way to gain TCO is to use whats called a trampoline. Instead of stepping deeper and deeper into nested function calls, the function is called once and the result, which is a function, is saved. In a loop the resulting function will be called and each invocation will return another function. This is done until a certain condition is passed and the loop ends.
*** Own TCO implementation
While ~loop~ provides a perfectly fine TCO for synchronise functions, in order to work with the asynchronous, action driven approach that reacl-c uses, a custom implementation needed to developed.
The principle of the trampoline remains, but instead of just calling the function, it is required to pass a Prog upwards and wait for a commit from the Prog.
*** Handling dynamic nature of nested monads in TCO
- Never know what next continuation might return
- Could be (again) a nested bind
- Could be just a Prog
- Commit might cause to go deeper into nested bind of cont
- Or bubble up to previous cont (of current bind)
*** Consequences of TCO
- Need to wrap "binds" to enable trampoline
- how to handle nested bind?
- Possible to traverse but potentially expensive book keeping because of continuation
- always need runner!
- ~(Prog a >>= Prog b) >>= Prog c~ not possible?
- should user have option to run something without TC or should they only have TC functions?
* Example usage
* Possible improvements
* Conclusion
