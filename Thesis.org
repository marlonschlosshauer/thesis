#+TITLE: Composition of UI elements in reacl-c using monads
#+AUTHOR: Marlon Schlosshauer, Angewandte Informatik, Hochschule Offenburg
#+LANGUAGE: de
#+OPTIONS: \n:t
#+LATEX_HEADER: \hypersetup{colorlinks=true, linkcolor=black}
#+LATEX_HEADER: \renewcommand*{\contentsname}{Inhaltsverzeichnis}
#+OPTIONS: broken-links:auto

* Motivation
Making components reusable is a common practice in modern frontend development. Often used to encapsulate styling and functionability into an easy to use component. While undoubtedly an essential feature, it is important to point out that, in modern Frameworks like React, this is used to either build a component or to compose multiple components into a single component.
Often the applications that are powered by these frameworks are a digitalization of a workflow, where the order of components, as in which component is shown after which other component, is crucial.
Yet the ability to build such workflows is often poorly or not at all supported. Given the lack of support and possible applications, it is of high interest to find a way to compose flows of components, easier.
* What is React
React is a popular UI framework developed by Facebook and written in JavaScript. Like other modern JavaScript frameworks, it is a Single-Page-Application (SPA), which means the entire application is available and loaded from a single page. Instead of having each page defined in HTML, developers are able to define their pages in JavaScript, using Reacts JavaScript Syntax Extension (JSX). React takes those JSX definitions and builds HTML accordingly, before adding it to the browsers DOM.
#+begin_src js
  const profile = ({name, age, image}) => {
      return (
	  <div className="profile-container">
	    <div className="profile-info-container">
	      <p>{name}</p>
	      <p>Age: {age}</p>
	    </div>
	    <img alt={`Avatar of ${name}`} src={image}/>
	  </div>
      )
  }
#+end_src
#+CAPTION: Example of JSX to define a profile

An advantage of a SPA design is that commonly used components, like a header and footer, can be shared over multiple pages without having to be retransmitted, as the JavaScript code is still in memory. In such a system navigation does not change the current page, but rather tells React to build the desired next page from the JSX definition. Besides requiring less bandwith on succesive visits, this also leads to better response times on page visits after the initial load, as those pages are also already in memory.

Another important feature of React is that the developer must explicitly declare the state of a component. This is used to improve performance, as only components which
which are effected by a state change are freshly render. Old components remain untouched in memory.

React is also a popular basis for other frameworks like Preact, Reagent, reacl-c and others.
* What is reacl-c
reacl-c is a UI framework for ClojureScript. Like other ClojureScript frameworks (Reagent, Om, Rum), reacl-c wraps React to take advantage  most of Clojures immutable datastructures. One of it's goal is to make components highly composible. Like React, reacl-c allows the defining of components, named items in reacl-c. These items can have child items, thus forming a tree, like in React.
A key difference to React, is that items can emit actions if an event occurs. These actions propogate upward the item tree. Every item can register an action handler which reacts to the action. This allows items to be not only just composed of functions, but also be independend of what any parent item might do with them. Instead of having to pass down a function to, e.g manipulate state, the component can give upwards an action to trigger the same functionability in the parent.
As an example: Take a button that toggles an "option" from ~true~ to ~false~ and back. The state for this "option" is put into the parent, as the child will be reused across the application. In React, the button needs to receive a function which to callback, after the button had been pressed. In reacl-c the button does not need to receive anything from the outside world (necessarily, styling and text might be applied), as the button emits an action when pressed, which the parent can capture and act upon.

Often another package like Redux is used to fix the problem of having to passdown functions in React. Instead of saving state in each component, state can be managed at a central point which components can send messages to, causing the central state to change. This can cause issues with the composibility of components. The problem with this approach is that components cannot be placed multiple times into the app, without making sure they don't all work on the same central state. reacl-c solves this issue by allowing any component to send and receive messages. Not only does this allow for local reasoning, but it also enables to wrap a component with an action handler and placing it infinitely in the app without worry, as the component won't effect anything outside of that handler.
* What is a monad
Monads can be described as chainable operations on common types which either transform data or control flow (as in step of the program). In this case they can be both, but are most likely used to control which things are executed and shown when.
A popular use case for monads is in the ~Maybe~ type in Haskell. The language doesn't feature a ~null~ keyword, instead we can ~Maybe~ to express when a function might be return ~Nothing~ or ~Just~ of something. What makes this type a monad is the fact that we can chain it together. This allows us to combine multiple operations that might fail and stop execution in case it does.
#+CAPTION: Instead of having to manually check if each operation succeded, thanks to the ~Maybe~ type and >>=Â (bind) operator, the chain will stop if one of the calls fails.
#+begin_src haskell
  getUserById "df743aec" >>= getTeamByUser >>= getTeamManagerByTeam >>= getSalaryById
#+end_src

To be a monad a type needs to implement two functions and comply with two rules. The required functions are >>= (also called bind) and return.
A bind takes an instance of a type and takes a function that gets a value and returns another instance of that type. The result of a bind will be another item of that type, so a monad. The second function, the return, takes a value and makes an monad of that type.

In Haskell notation these functions are writen as follows:
#+begin_src haskell
  M a >>= (a -> M b) = M b
  return a = M a
#+end_src
* Current State
Composition is supported in both reacl-c and other frontend frameworks like Angular or React etc. However, in all cases this is limited to creating a new component that just displays all composed components at the same time. To create a component which initially display some component and later changes to display another component, after a certain event has been reached, the logic doing the change from one to the other component, needs to be implemented by hand.
A common way to implement this, is to use a switch statement in combination with a variable to keep track of state. Once a certain event (like a click on a button) has occured, the component changes the state to allow for the next component to be rendered.
#+begin_src javascript
  const login = () => {
      const [step, setStep] = useState(0);
      const [value, setValue] = useState();

      const cb = x => {setStep(step+1); setValue(x)};

      return switch(step) {
	  case 0:
	  return (<personalInfo value={value} cb={cb}/>) ;
	  case 1:
	  return (<verificationCode value={value} cb={cb}/>) ;
	  case 2:
	  return (<showAccountInfo value={value}/>) ;
      }
  }
#+end_src
A simple implementation of a component which shows multiple components succesively can be seen in Listing 1. ~personalInfo~, ~verificationCode~, ~showAccountInfo~ are components will be shown one after another. The ~step~ variable stores the which variable should currently be shown. The ~value~ variable stores the result of the last step. In order to progress, a callback named ~cb~ needs to be passed to all components, as the point at which the child components are finished can't be deteremed from outside (in React). The steps are arranged in sequential order, but it is also possible to move non-linearly or even revisit components mutliple times. This does mean the callback function needs to map from where which component is being routed. This will be examined in more detail in Listing 2.
Another property to keep in mind is that the components need to be able to at least take a callback function for when they're done. This means components might need to be changed to fit our new logic.
#+begin_src clojurescript
  (defn login []
    (handle-action
     (dynamic
      (fn [[step val]]
	(case
	    :personal (personal-info val)
	    :verification (verification-code val)
	    :show (show-account-info val))))
     (fn [[step _] ac]
       (return
	:state
	[(case step
	   :personal :verification
	   :verification (if (nil? ac) :verification :show)
	   :show :show) ac]))))
#+end_src
Listing 2 shows the example from Listing 1, but instead of using an increasing number to keep track of which step the component is on, a keyword is used which could be used to components in a non-linear order, loop back to the inital component after visiting the final component, or showing a component multiple times (with different values each time). But this means a second switch statement is needed, to map the transitions from one component to another. This makes adding components more difficult, as two places need to be maintained to do so. It is also very easy to lose track of which component will be shown next, if a complex order is choosen, as no support is being provided by either the language or the framework.
* Desired Behaviour
The design goals are to create a both easy to use and powerful tool to compose flows together into a single entitiy. For the part that will allow the executing of the composed flow, inspiration is taken from the ClojureScript ~let~ function, which has an easy to use syntax thanks to the use of a macros. As seen in Listing 3, a ~let~ is composed of two parameters. The first parameter is a list of ~mapping:value~ pairs, where a mapping is nothing but a name to be used within the ~let~ and a value is the actual value of that name. The second parameter, the body, is a function which can use the mappings given in the first parameter, to execute some operation.
#+begin_src clojurescript
  (let [one 1
	two (+ 1 one)
	three (inc (* two one))]
    (+ one two three))
#+end_src
So in our example ~one~, ~two~, ~three~ are at first only names, but are bound to the values given on the right, inside of the body. This is actually just syntactical sugar. The same could be expressed with annonymous functions as seen in Listing 4.
#+begin_src clojurescript
  ((fn [one]
     ((fn [two]
	((fn [three]
	   (+ one two three))
	 (inc (* two one))))
      (+ 1 one))) 1)
#+end_src
A similiar behaviour would be desired as it is both concise yet easily readable, as well as being already understood by ClojureScript developers.

One key feature is the need for synchronosity. Only one value is shown to the user at a time and that is the current value in our list of ~mapping:value~ pairs. Execution of pairs further in the list is halted until they're reached (in the list). Same shall hold true for potential HTTP requests which are added to the list.
Future pairs should also be able to access the value returned by the earlier pairs, just like how you can access ~one~ while calculating the value of ~two~ in our ~let~ example earlier.
Of-course individual values in the ~mapping:value~ pairs should also be able to be composible with other values, so one step in one flow, can be an entire different, nested, flow.

Listings 5 shows our earlier example implemented with the desired functionality given by the framework. Note how little code is needed
#+begin_src clojurescript
  (runner [personal (personal-info)
	   verification (verification-code personal)]
	  (show-account-info [personal verification]))
#+end_src
A possible alternative to this would be to omit the body entirely and instead use the element previously placed in the body, as the last element in our ~mapping:value~ pairs list.
#+begin_src clojurescript
  (runner [personal (personal-info)
	   verification (verification-code personal)
	   info (show-account-info [personal verification])])
#+end_src
* Implementation
** Specifics
*** Types
- Item
- Commit
- Prog
*** Functions
- return
- then
- show
- runner
** Whats the semantic of the functions?
** What is the result of the last continutation?
Because reacl-c allows us to emit actions which propagate up the element tree, we can do more than to just display the result on the screen or have the data be returned from the ~runner~ in it's raw form. The ~runner~ could hold on the last ~Prog~, disply it and propagate the result of it upwards. This might be useful if the ~runner~ consists of a lot of chained together HTTP requests, as the logic to capture the result of the requets would have to live in an action handler anyways.

** How does the "Item" world and "Prog" world interact?
* Optimisation
** Tail Call Optimisation
Neither Java nor JavaScript, the the two host languages for Clojure and ClojureScript respectively, feature Tail Call Optimization (TCO). Due to the high amount of nested function calls it is how ever a very important feature for a functional language. With a correct implementation of Tail Call Optimisation it is guarenteed that successive invocations of a monadic bind won't cause a stack overflow. It can also enable the use of recursion with our bind elements.
It is therefore important to abstract away the bind logic from the developer, to implement some kind of TCO around it.
*** Tail Call Optimisation in ClojureScript
While ClojureScript isn't offering TCO out-of-the-box for every function call, it does ship with the ~loop~ function which enables TCO for calls that are done at the tail end of the body, passed to the function. This kind of TCO is called a trampoline, because instead of stepping deeper and deeper into nested function calls, the ~loop~ is calling the body, which returns a function. That function is then called in a loop until a certain condition is passed. The called function returns another function in every invocation, rather than just a value.
*** Own TCO implementation
While ~loop~ provides a perfectly fine TCO for synchronose functions, in order to work with the asynchronoes, action driven approach that reacl-c uses, a custom implementation needed to developed.
The principle of the trampoline remains, but instead of just calling the function, it is required to pass a Prog upwards and wait for a commit from the Prog.
*** Consequences of TCO
- Need to wrap "binds" to enable trampoline
- how to handle nested bind?
- Possible to traverse but potentially expensive book keeping because of continuation
- always need runner!
- ~(Prog a >>= Prog b) >>= Prog c~ not possible?
- should user have option to run something without TC or should they only have TC functions?
