#+TITLE: Composition of UI elements in reacl-c using monads
#+AUTHOR: Marlon Schlosshauer, Angewandte Informatik, Hochschule Offenburg
#+LANGUAGE: de
#+OPTIONS: \n:t
#+LATEX_HEADER: \hypersetup{colorlinks=true, linkcolor=black}
#+LATEX_HEADER: \renewcommand*{\contentsname}{Inhaltsverzeichnis}
#+OPTIONS: broken-links:auto

* Motivation
Making components reusable is a common practice in modern frontend development. Often used to encapsulate styling and functionability into an easy to use component. While undoubtedly an essential feature, it is important to point out that, in modern Frameworks like React, this is used to either build a component or to compose multiple components into a single component.
Often the applications that are powered by these frameworks are a digitalization of a workflow, where the order of components, as in which component is shown after which other component, is crucial.
Yet the ability to build such workflows is often poorly or not at all supported. Given the lack of support and possible applications, it is of high interest to find a way to compose flows of components, easier.
* What is React
React is a popular UI framework developed by Facebook and written in JavaScript. Like other modern JavaScript frameworks, it is a Single-Page-Application (SPA), which means the entire application is available and loaded from a single page. Instead of having each page defined in HTML, developers are able to define their pages in JavaScript, using Reacts JavaScript Syntax Extension (JSX). React takes those JSX definitions and builds HTML accordingly, before adding it to the browsers DOM.
An advantage of a SPA design is that commonly used components, like a header and footer, can be shared over multiple pages without having to be retransmitted, as the JavaScript code is still in memory. In such a system navigation does not change the current page, but rather tells React to build the desired next page from the JSX definition. Besides requiring less bandwith on succesive visits, this also leads to better response times on page visits after the initial load, as those pages are also already in memory.

Another important feature of React is that the developer must explicitly declare the state of a component. This is used to improve performance, as only components which come in contact with that state are updated upon a change of values.

React is used as a basis for other frameworks like Preact, Reagent, reacl-c and others.
* What is reacl-c
reacl-c is a UI framework for ClojureScript. Like other ClojureScript frameworks (Reagent, Om, Rum), reacl-c wraps React to make the most of Clojures immutable datastructures. One of it's goal is to make components highly composible. Like React, reacl-c allows the defining of components, named items in reacl-c. These items can have child items, thus forming a tree, like in React.
A key difference to React, is that items can emit actions if an event occurs. These actions propogate upward the item tree. Every item can register an action handler which reacts to the action. This allows items to be not only just composed of functions, but also be independend of what any parent item might do with them. Instead of having to pass down a function to, e.g manipulate state, the component can give upwards an action to trigger the same functionability in the parent.
As an example: Take a button that toggles an "option" from ~true~ to ~false~ and back. The state for this "option" is put into the parent, as the child will be reused across the application. In React, the button needs to receive a function which to callback, after the button had been pressed. In reacl-c the button does not need to receive anything from the outside world (necessarily, styling and text might be applied), as the button emits an action when pressed, which the parent can capture and act upon.

Often another package like Redux is used to fix the problem of having to passdown functions in React. Instead of saving state in each component, state can be managed at a central point which components can send messages to, causing the central state to change. This can cause issues with the composibility of components. The problem with this approach is that components cannot be placed multiple times into the app, without making sure they don't all work on the same central state. reacl-c solves this issue by allowing any component to send and receive messages. Not only does this allow for local reasoning, but it also enables to wrap a component with an action handler and placing it infinitely in the app without worry, as the component won't effect anything outside of that handler.
* What is a monad
Monads can be described as chainable operations on common types which either transform data or control flow (as in step of the program). In this case they can be both, but are most likely used to control which things are executed and shown when.
A popular use case for monads is in the ~Maybe~ type in Haskell. The language doesn't feature a ~null~ keyword, instead we can ~Maybe~ to express when a function might be return ~Nothing~ or ~Just~ of something. What makes this type a monad is the fact that we can chain it together. This allows us to combine multiple operations that might fail and stop execution in case it does.
#+CAPTION: Instead of having to manually check if each operation succeded, thanks to the ~Maybe~ type and >>=Â (bind) operator, the chain will stop if one of the calls fails.
#+begin_src haskell
  getUserById "df743aec" >>= getTeamByUser >>= getTeamManagerByTeam >>= getSalaryById
#+end_src

To be a monad a type needs to implement two functions and comply with two rules. The required functions are >>= (also called bind) and return.
A bind takes an instance of a type and takes a function that gets a value and returns another instance of that type. The result of a bind will be another item of that type, so a monad. The second function, the return, takes a value and makes an monad of that type.

In Haskell notation these functions are writen as follows:
#+begin_src haskell
  M a >>= (a -> M b) = M b
  return a = M a
#+end_src
* Current State
* Desired Behaviour
* Implementation
** Whats the semantic of the functions?
** What is the result of the last continutation?
** How does the "Item" world and "Prog" world interact?
* Optimisation
** Tail Call Optimisation
Neither Java nor JavaScript, the the two host languages for Clojure and ClojureScript respectively, feature Tail Call Optimization (TCO). Due to the high amount of nested function calls it is how ever a very important feature for a functional language. With a correct implementation of Tail Call Optimisation it is guarenteed that successive invocations of a monadic bind won't cause a stack overflow. It can also enable the use of recursion with our bind elements.
It is therefore important to abstract away the bind logic from the developer, to implement some kind of TCO around it.
*** Tail Call Optimisation in ClojureScript
While ClojureScript isn't offering TCO out-of-the-box for every function call, it does ship with the ~loop~ function which enables TCO for calls that are done at the tail end of the body, passed to the function. This kind of TCO is called a trampoline, because instead of stepping deeper and deeper into nested function calls, the ~loop~ is calling the body, which returns a function. That function is then called in a loop until a certain condition is passed. The called function returns another function in every invocation, rather than just a value.
*** Own TCO implementation
While ~loop~ provides a perfectly fine TCO for synchronose functions, in order to work with the asynchronoes, action driven approach that reacl-c uses, a custom implementation needed to developed.
The principle of the trampoline remains, but instead of just calling the function, it is required to pass a Prog upwards and wait for a commit from the Prog.
